## å‘½ä»¤

### ttl

å½“ key ä¸å­˜åœ¨æ—¶ï¼Œè¿”å› -2 ã€‚ å½“ key å­˜åœ¨ä½†æ²¡æœ‰è®¾ç½®å‰©ä½™ç”Ÿå­˜æ—¶é—´æ—¶ï¼Œè¿”å› -1 ã€‚ å¦åˆ™ï¼Œä»¥æ¯«ç§’ä¸ºå•ä½ï¼Œè¿”å› key çš„å‰©ä½™ç”Ÿå­˜æ—¶é—´ã€‚

æ³¨æ„ï¼šåœ¨ Redis 2.8 ä»¥å‰ï¼Œå½“ key ä¸å­˜åœ¨ï¼Œæˆ–è€… key æ²¡æœ‰è®¾ç½®å‰©ä½™ç”Ÿå­˜æ—¶é—´æ—¶ï¼Œå‘½ä»¤éƒ½è¿”å› -1 ã€‚

### äº‹åŠ¡

ç¤ºä¾‹ä»¥ä¸‹ç¤ºä¾‹è¯´æ˜äº†å¦‚ä½•å¯åŠ¨å’Œæ‰§è¡ŒRedisäº‹åŠ¡ã€‚

```
redis 127.0.0.1:6379> MULTI
OK
redis 127.0.0.1:6379> SET mykey "redis"
QUEUED
redis 127.0.0.1:6379> GET mykey
QUEUED
redis 127.0.0.1:6379> INCR visitors
QUEUED
redis 127.0.0.1:6379> EXEC
1) OK
2) "redis"
3) (integer) 1
```

### redis äº‹åŠ¡å‘½ä»¤

ä¸‹è¡¨åˆ—å‡ºäº†ä¸Redisäº‹åŠ¡ç›¸å…³çš„ä¸€äº›åŸºæœ¬å‘½ä»¤ã€‚
|åºå·|å‘½ä»¤|è¯´æ˜|
|----|----|----|
|1 |discard |ä¸¢å¼ƒåœ¨MULTIä¹‹åå‘å‡ºçš„æ‰€æœ‰å‘½ä»¤ |
|2|exec|æ‰§è¡ŒMULTIåå‘å‡ºçš„æ‰€æœ‰å‘½ä»¤|
|3|multi|æ ‡è®°äº‹åŠ¡å—çš„å¼€å§‹|
|4|unwatch|å–æ¶ˆ WATCH å‘½ä»¤å¯¹æ‰€æœ‰ key çš„ç›‘è§†|
|5|WATCH key [key â€¦]|ç›‘è§†ç»™å®šçš„é”®ä»¥ç¡®å®šMULTI / EXECå—çš„æ‰§è¡Œ|

### äº‹åŠ¡ä¸­å‡ºç°å¼‚å¸¸

å‘ç°åªæœ‰åœ¨exec ä¹‹åï¼Œå‰é¢çš„å…·ä½“äº‹åŠ¡æ“ä½œä¸­çš„å¼‚å¸¸æ‰ä¼šæ‰“å°å‡ºæ¥

```sh
127.0.0.1:6379[1]> multi
OK
127.0.0.1:6379[1]> ZINCRBY score: topic:1 100 // è¿™ä¸ªåº”è¯¥æ˜¯ zincrb score: 100 topic:1
QUEUED
127.0.0.1:6379[1]> exec
1) (error) ERR value is not a valid float
127.0.0.1:6379[1]>
```

çœ‹redis å®˜æ–¹æ–‡æ¡£[åŸæ–‡](https://redis.io/topics/transactions)
redis å°±æ˜¯ä¸æ”¯æŒäº‹åŠ¡

```sh
127.0.0.1:6379[1]> hgetall topic:1
 1) "like_count"
 2) "12"
 3) "user_id"
 4) "11174736"
 5) "name"
 6) "title"
 7) "comment_count"
 8) "0"
 9) "description"
10) "content"
127.0.0.1:6379[1]> multi
OK
127.0.0.1:6379[1]> hincrby topic:1 like_count 100   // å°±ç®—åé¢ä¸€ä¸ªå‘½ä»¤å‡ºé”™ï¼Œä½†æ˜¯è¿™ä¸€å¥ç¡®å®æ‰§è¡Œäº†
QUEUED
127.0.0.1:6379[1]> ZINCRBY score: topic:1 100   // è¿™ä¸€ä¸ªå‘½ä»¤å‡ºé”™ï¼Œä½†æ˜¯ä¸å½±å“å…¶å®ƒå‘½ä»¤æ‰§è¡Œ
QUEUED
127.0.0.1:6379[1]> exec
1) (integer) 112
2) (error) ERR value is not a valid float
127.0.0.1:6379[1]> hgetall topic:1
 1) "like_count"
 2) "112"
 3) "user_id"
 4) "11174736"
 5) "name"
 6) "title"
 7) "comment_count"
 8) "0"
 9) "description"
10) "content"
127.0.0.1:6379[1]>
```

```
EXEC returned two-element Bulk string reply where one is an OK code and the other an -ERR reply. It's up to the client library to find a sensible way to provide the error to the user.

**It's important to note that even when a command fails, all the other commands in the queue are processed â€“ Redis will not stop the processing of commands.**
```

#### Why Redis does not support roll backs? 

ä¸æ”¯æŒå›æ»šï¼ŒåŸå› æœ‰2ï¼š
1. ä¸€èˆ¬æ€§çš„å‡ºé”™åŸå› éƒ½æ˜¯program å‡ºé”™ï¼Œè¯­æ³•é”™è¯¯ï¼Œå¾ˆå®¹æ˜“åœ¨å¼€å‘è¿‡ç¨‹ä¸­å‘ç°å¹¶æ”¹æ­£ã€‚
2. å†…éƒ¨å®ç°ç®€å•ï¼Œå¿«é€Ÿï¼Œä¸éœ€è¦å›æ»š

```
If you have a relational databases background, the fact that Redis commands can fail during a transaction, but still Redis will execute the rest of the transaction instead of rolling back, may look odd to you.

However there are good opinions for this behavior:

Redis commands can fail only if called with a wrong syntax (and the problem is not detectable during the command queueing), or against keys holding the wrong data type: this means that in practical terms a failing command is the result of a programming errors, and a kind of error that is very likely to be detected during development, and not in production.
Redis is internally simplified and faster because it does not need the ability to roll back.
An argument against Redis point of view is that bugs happen, however it should be noted that in general the roll back does not save you from programming errors. For instance if a query increments a key by 2 instead of 1, or increments the wrong key, there is no way for a rollback mechanism to help. Given that no one can save the programmer from his or her errors, and that the kind of errors required for a Redis command to fail are unlikely to enter in production, we selected the simpler and faster approach of not supporting roll backs on errors.
```

### LRU Cacheç®—æ³•ä»¥åŠåœ¨redisä¸­çš„åº”ç”¨

[åŸæ–‡](https://zhuanlan.zhihu.com/p/40354122)

è¦†ç›–ä¸€ä¸ªç°å­˜çš„å—çš„æ—¶å€™ä¼šä½¿ç”¨æ›¿æ¢ç­–ç•¥ï¼Œæ›¿æ¢ç­–ç•¥æœ‰å¾ˆå¤šç§ï¼Œä¸»è¦æœ‰ï¼š
- LRU - Least Recently Used
LRUæ˜¯å¾ˆå¸¸ç”¨çš„æ›¿æ¢ç­–ç•¥ï¼Œé€šå¸¸çš„å®ç°ä¼šæœ‰ä¸€ä¸ªage counterï¼ˆæ›¿æ¢indexï¼‰ä¸æ¯ä¸ªæ•°ç»„Sç›¸å…³ã€‚è¿™ä¸ªcounteræœ€å¤§å€¼å°±æ˜¯Sï¼Œå½“ä¸€ä¸ªsetè¢«è®¿é—®åˆ°ï¼Œé‚£ä¹ˆæ¯”å®ƒä½çš„counterå°±è¢«ç½®ä¸º0ï¼Œå…¶ä»–setè‡ªå¢1ã€‚
- FIFO - First-In First-Out
å…ˆè¿›å…ˆå‡ºç­–ç•¥ã€‚
- LFU â€“ Least Frequently Used
å¾ˆé«˜æ•ˆçš„ç®—æ³•ï¼Œä½†å¾ˆè€—èµ„æºï¼Œé€šå¸¸ä¸ç”¨ã€‚
- Round-robin
æœ‰ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å°†è¦è¢«æ›¿æ¢çš„è¡Œï¼Œå½“è¡Œè¢«æ›¿æ¢ï¼ŒæŒ‡é’ˆå°±ä¼šè‡ªå¢1ï¼ŒæŒ‡é’ˆæ˜¯ç¯å½¢çš„ã€‚
- Random
éšæœºç­–ç•¥ï¼Œç”¨äºå…¨ç›¸è”é«˜é€Ÿç¼“å­˜ã€‚æ¯ä¸ªæ—¶åºRound-robinå°±è¦æ›´æ–°ï¼Œè€Œä¸æ˜¯æ¯ä¸ªæ›¿æ¢æ“ä½œã€‚

### linuxä¸­çš„æ–‡ä»¶æè¿°ç¬¦(file descriptor)å’Œæ–‡ä»¶
[åŸæ–‡](https://www.jianshu.com/p/504a53c30c17)

linuxä¸ºäº†å®ç°ä¸€åˆ‡çš†æ–‡ä»¶çš„è®¾è®¡å“²å­¦ï¼Œä¸ä»…å°†æ•°æ®æŠ½è±¡æˆäº†æ–‡ä»¶ï¼Œä¹Ÿå°†ä¸€åˆ‡æ“ä½œå’Œèµ„æºæŠ½è±¡æˆäº†æ–‡ä»¶ï¼Œæ¯”å¦‚è¯´ç¡¬ä»¶è®¾å¤‡ï¼Œsocketï¼Œç£ç›˜ï¼Œè¿›ç¨‹ï¼Œçº¿ç¨‹ç­‰ã€‚
è¿™æ ·çš„è®¾è®¡å°†ç³»ç»Ÿçš„æ‰€æœ‰åŠ¨ä½œéƒ½ç»Ÿä¸€èµ·æ¥ï¼Œå®ç°äº†å¯¹ç³»ç»Ÿçš„åŸå­åŒ–æ“ä½œï¼Œå¤§å¤§é™ä½äº†ç»´æŠ¤å’Œæ“ä½œçš„éš¾åº¦ï¼Œæƒ³æƒ³çœ‹ï¼Œå¯¹äºsocketï¼Œç¡¬ä»¶è®¾å¤‡ï¼Œæˆ‘ä»¬åªè¦è¯»è¯»å†™å†™æ–‡ä»¶å°±èƒ½å¯¹å…¶è¿›è¡Œæ“ä½œæ˜¯å¤šä¹ˆçˆ½çš„ä¸€ä»¶äº‹

é‚£ä¹ˆåœ¨æ“ä½œè¿™äº›æ‰€è°“çš„æ–‡ä»¶çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¸å¯èƒ½æ²¡æ“ä½œä¸€æ¬¡å°±è¦æ‰¾ä¸€æ¬¡åå­—å§ï¼Œè¿™æ ·ä¼šè€—è´¹å¤§é‡çš„æ—¶é—´å’Œæ•ˆç‡ã€‚å’±ä»¬å¯ä»¥æ¯ä¸€ä¸ªæ–‡ä»¶æ“ä½œä¸€ä¸ªç´¢å¼•ï¼Œè¿™æ ·ï¼Œè¦æ“ä½œæ–‡ä»¶çš„æ—¶å€™ï¼Œæˆ‘ä»¬ç›´æ¥æ‰¾åˆ°ç´¢å¼•å°±å¯ä»¥å¯¹å…¶è¿›è¡Œæ“ä½œäº†ã€‚æˆ‘ä»¬å°†è¿™ä¸ªç´¢å¼•å«åšæ–‡ä»¶æè¿°ç¬¦ï¼ˆfile descriptorï¼‰ï¼Œç®€ç§°fdï¼Œåœ¨ç³»ç»Ÿé‡Œé¢æ˜¯ä¸€ä¸ªéè´Ÿçš„æ•´æ•°ã€‚æ¯æ‰“å¼€æˆ–åˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œå†…æ ¸å°±ä¼šå‘è¿›ç¨‹è¿”å›ä¸€ä¸ªfdï¼Œç¬¬ä¸€ä¸ªæ‰“å¼€æ–‡ä»¶æ˜¯0,ç¬¬äºŒä¸ªæ˜¯1,ä¾æ¬¡é€’å¢ã€‚

æˆ‘ä»¬å¹³æ—¶è¯´çš„å‘½ä»¤å¦‚./test.sh>res2.log 2>&1å°±æ˜¯å°†æ ‡å‡†å’Œé”™è¯¯çš„è¾“å‡ºæµé‡å®šå‘åˆ°logæ–‡ä»¶é‡Œé¢ï¼Œé€šå¸¸æƒ…å†µä¸‹ç³»ç»Ÿå¯åŠ¨åä¼šè‡ªåŠ¨å¯åŠ¨æ–‡ä»¶æè¿°ç¬¦å·0,1,2ï¼Œå½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥å…³é—­è¿™å‡ ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œæ¯”å¦‚å…³æ‰1,ç„¶åæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼Œé‚£ä¹ˆåˆ°æ—¶å€™ä½ ä½¿ç”¨ä»£ç ä¸­çš„printfå°±ä¸ä¼šè¾“å‡ºåˆ°ç»ˆç«¯ï¼Œè€Œæ˜¯ä¼šè¾“å…¥åˆ°ä½ æ‰“å¼€çš„æ–‡ä»¶é‡Œé¢ï¼ˆè¿™æ ·åœ¨æµ‹è¯•çš„æ—¶å€™å…å»äº†æˆ‘ä»¬åœ¨ä»£ç é‡Œé¢å†™logçš„éº»çƒ¦ï¼‰

åœ¨pythonä¸­å¯ä»¥ç”¨å¦‚ä¸‹æ‹¿åˆ°fdï¼Œåœ¨linuxä¸‹fdå«åšæ–‡ä»¶æè¿°ç¬¦ï¼Œåœ¨windowä¸‹fdå«åšå¥æŸ„ï¼Œæ‰€ä»¥è¿™å°±è¯´æ˜äº†ä¸ºå•¥åœ¨å®˜æ–¹æ–‡æ¡£ä¸­filenoè§£é‡Šæ˜¯Return the file descriptor or handle used by the connection.

åœ¨linuxå†…æ ¸ä¸­é€šå¸¸ä¼šæœ‰ä¸ªtask_structç»“æ„ä½“æ¥ç»´æŠ¤è¿›ç¨‹ç›¸å…³çš„è¡¨ï¼Œå«è¿›ç¨‹æ§åˆ¶å—ï¼Œè¿™ä¸ªå—é‡Œé¢ä¼šæœ‰æŒ‡é’ˆæŒ‡å‘file_structçš„ç»“æ„ä½“ï¼Œç§°ä¸ºæ–‡ä»¶æè¿°è¡¨ï¼Œæ–‡ä»¶æè¿°ç¬¦å°±æ˜¯è¿™ä¸ªè¡¨çš„ç´¢å¼•ã€‚

è€Œè¿™ä¸ªfile_structä¼šæŒ‡å‘ä¸€ä¸ªfileçš„ç»“æ„ä½“ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œè¿›ç¨‹æ˜¯æ²¡æœ‰åŠæ³•ç›´æ¥è®¿é—®æ–‡ä»¶çš„ï¼Œåªèƒ½é€šè¿‡æ–‡ä»¶æè¿°è¡¨é‡Œé¢çš„æ–‡ä»¶æè¿°ç¬¦æ‰¾åˆ°æ–‡ä»¶ã€‚fileæœ‰å‡ ä¸ªä¸»è¦çš„ç»“æ„ä½“æˆå‘˜ï¼Œåˆ†åˆ«æ˜¯countï¼Œfile_operationå’Œdentryï¼ˆdirectory entryï¼‰ã€‚
countï¼šè¿™ä¸ªæ˜¯å¼•ç”¨è®¡æ•°ï¼Œåƒä¸Šé¢çš„pipeï¼Œè¿˜æœ‰forkï¼Œdupç­‰çš„æ–‡ä»¶æè¿°ç¬¦å¯èƒ½ä¼šæŒ‡å‘åŒä¸€ä¸ªfileï¼Œæ¯”å¦‚ç°åœ¨æœ‰fd1å’Œfd2ï¼Œä»–ä»¬éƒ½æŒ‡å‘äº†åŒä¸€ä¸ªæ–‡ä»¶ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–‡ä»¶çš„è®¡æ•°å°±æ˜¯2,è¦æƒ³å…³é—­è¿™ä¸ªæ–‡ä»¶ï¼Œcloseï¼ˆfd1ï¼‰æ˜¯ä¸èƒ½å…³æ‰çš„ï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™è®¡æ•°ä¸º1,åªæœ‰åœ¨è®¡æ•°ä¸º0çš„æ—¶å€™æ‰ç®—å®Œå…¨å…³é—­
file_operationï¼šè¿™ä¸ªæŒ‡å‘çš„æ–‡ä»¶æ“ä½œæŒ‡é’ˆï¼Œfile_operationé‡Œé¢åŒ…å«äº†å¯¹æ–‡ä»¶æ“ä½œçš„å†…æ ¸å‡½æ•°æŒ‡é’ˆï¼Œä»–æŒ‡å‘å†…æ ¸æ“ä½œå‡½æ•°ï¼Œæ¯”å¦‚è¯´readï¼Œwriteï¼Œreleaseï¼Œopenï¼Œå½“ç„¶ï¼Œä¸åŒçš„æ–‡ä»¶file_opertionsæœ‰ä¸åŒçš„æ“ä½œï¼Œåƒè¯»å–å­—ç¬¦è®¾å¤‡çš„æ–‡ä»¶æ“ä½œè‚¯å®šä¸ä¼šå’Œè¯»å–æ­£å¸¸æ–‡ä»¶çš„ä¸€æ ·ï¼Œä»–ä»¬ä¸æ˜¯è¯»å–ç£ç›˜ï¼Œè€Œæ˜¯è¯»å–ç¡¬ä»¶è®¾å¤‡
dentryï¼šç›®å½•é¡¹ï¼Œä¸€ä¸ªæŒ‡å‘å¸¦æœ‰æ–‡ä»¶è·¯å¾„çš„dentryç»“æ„ä½“æŒ‡é’ˆï¼Œæˆ‘ä»¬åœ¨æ“ä½œæ–‡ä»¶æ—¶ï¼Œä¸€å®šè¦çŸ¥é“ä»–çš„è·¯å¾„ï¼Œæ‰èƒ½è¿›è¡Œæ“ä½œã€‚ä¸ºäº†å‡å°‘è¯»ç›˜æ¬¡æ•°,å†…æ ¸ç¼“å­˜äº†ç›®å½•çš„æ ‘çŠ¶ç»“æ„,ç§°ä¸ºdentry cache,å…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹æ˜¯ä¸€ ä¸ªdentryç»“æ„ä½“,åªè¦æ²¿ç€è·¯å¾„å„éƒ¨åˆ†çš„dentryæœç´¢å³å¯ã€‚

ç°åœ¨çœ‹ä¸‹dentryè¿™ä¸ªç»“æ„ä½“æŒ‡å‘äº†ä»€ä¹ˆï¼Ÿ
dentryæŒ‡å‘äº†inodeï¼Œinodeæ˜¯ä¸€ä¸ªåŒ…å«æ‰€æœ‰è€…ã€æ–‡ä»¶å¤§å°ã€æ–‡ä»¶ç±»å‹å’Œæƒé™ä½ï¼Œåˆ›å»ºã€ä¿®æ”¹å’Œæ›´æ–°æ—¶é—´ç­‰çš„ç»“æ„ä½“ï¼Œä¿å­˜ç€ä»ç£ç›˜inodeè¯»ä¸Šæ¥çš„ä¿¡æ¯ã€‚é‡Œé¢è¿˜æœ‰ä¸¤ä¸ªé‡è¦çš„æˆå‘˜ï¼š
åˆ†åˆ«æ˜¯inode_opertionså’Œsuper_block
inode_opertionsï¼šæ˜¯æè¿°æ–‡ä»¶èƒ½è¿›è¡Œå“ªäº›æ“ä½œçš„ç»“æ„ä½“ï¼Œä»–æŒ‡å‘äº†æ–‡ä»¶æ“ä½œçš„å†…æ ¸å‡½æ•°ï¼Œæ¯”å¦‚è¯´rmï¼Œmkdirï¼Œmvç­‰ï¼Œ
super_blockï¼šä¿å­˜ç€ä»ç£ç›˜åˆ†åŒºçš„è¶…çº§å—è¯»ä¸Šæ¥çš„ä¿¡æ¯ï¼Œåƒæ–‡ä»¶ç³»ç»Ÿç±»å‹ï¼ˆæ¯”å¦‚è¯´æ˜¯ext2ï¼Œext3ç­‰ï¼‰ï¼Œå—å¤§å°ï¼Œä¸åŒçš„æ–‡ä»¶ç±»å‹ï¼Œåº•å±‚çš„å®ç°æ˜¯ä¸åŒçš„ã€‚å½“ç„¶ï¼Œsuper_blockè¿˜æœ‰s_rootä¸ªæˆå‘˜æŒ‡å‘äº†dentryï¼Œå› ä¸ºä»–éœ€è¦çŸ¥é“æ–‡ä»¶çš„æ ¹ç›®å½•è¢«mount åˆ°å“ªé‡Œ
file ã€dentryã€inode ã€super_blockè¿™å‡ ä¸ªç»“æ„ä½“ç»„æˆäº†VFSçš„æ ¸å¿ƒæ¦‚å¿µ

### redis ziplist redisæºç ä¹‹å‹ç¼©åˆ—è¡¨ziplist

[åŸæ–‡](https://blog.csdn.net/qiangzhenyi1207/article/details/80353104)
è¿ç»­ï¼Œæ— åºçš„æ•°æ®ç»“æ„ã€‚å‹ç¼©åˆ—è¡¨æ˜¯ Redis ä¸ºäº†èŠ‚çº¦å†…å­˜è€Œå¼€å‘çš„ï¼Œ ç”±ä¸€ç³»åˆ—ç‰¹æ®Šç¼–ç çš„è¿ç»­å†…å­˜å—ç»„æˆçš„é¡ºåºå‹ï¼ˆsequentialï¼‰æ•°æ®ç»“æ„ã€‚

### key notification redisæ•°æ®åº“é€šçŸ¥

[åŸæ–‡](https://www.cnblogs.com/zhangchao-letv/articles/6121635.html)
æ•°æ®åº“é€šçŸ¥æ˜¯Redis2.8ç‰ˆæœ¬æ–°å¢åŠ çš„åŠŸèƒ½,è¿™ä¸ªåŠŸèƒ½å¯ä»¥è®©å®¢æˆ·ç«¯é€šè¿‡è®¢é˜…ç»™å®šçš„é¢‘é“æˆ–è€…æ¨¡å¼,æ¥è·çŸ¥æ•°æ®åº“ä¸­é”®çš„å˜åŒ–,ä»¥åŠæ•°æ®åº“ä¸­å‘½ä»¤çš„æ‰§è¡Œæƒ…å†µã€‚
ä¸¾ä¸ªä¾‹å­,ä»¥ä¸‹ä»£ç å±•ç¤ºäº†å®¢æˆ·ç«¯å¦‚ä½•è·å–0å·æ•°æ®åº“ä¸­é’ˆå¯¹messageé”®æ‰§è¡Œçš„æ‰€æœ‰å‘½ä»¤:

```
127.0.0.1:6379>SUBSCRIBE__keyspace@0__:message
Reading messages . . . (press Ctrl-C to quit)
1) "subscribe"            //è®¢é˜…ä¿¡æ¯
2) "_ _keyspace@0_:message"
3) (integer) 1
1) "message" //æ‰§è¡ŒSET å‘½ä»¤
2) "_ _keyspace@0_: message"
3) "set"
1) "message" //æ‰§è¡ŒEXPIEå‘½ä»¤
2) " keyspace@0_:message"
3) "expire"
1) "message" //æ‰§è¡ŒDEL å‘½ä»¤
2) "_ _keyspace@0_: message "
3) "de1"
```
æ ¹æ®å‘å›çš„é€šçŸ¥æ˜¾ç¤ºï¼Œå…ˆåå…±æœ‰SETã€EXPlRE ã€DEL ä¸‰ä¸ªå‘½ä»¤å¯¹é”®messageè¿›è¡Œäº†æ“ä½œã€‚

è¿™ä¸€ç±»å…³æ³¨"æŸä¸ªé”®æ‰§è¡Œäº†ä»€ä¹ˆå‘½ä»¤"çš„é€šçŸ¥ç§°ä¸ºé”®ç©ºé—´é€šçŸ¥(key-space-notification),é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰å¦ä¸€ç±»ç§°ä¸ºé”®äº‹ä»¶é€šçŸ¥(key-event-notification)çš„é€šçŸ¥,å®ƒä»¬å…³æ³¨çš„æ˜¯"æŸä¸ªå‘½ä»¤è¢«ä»€ä¹ˆé”®æ‰§è¡Œäº†" ã€‚
ä»¥ä¸‹æ˜¯ä¸€ä¸ªé”®äº‹ä»¶é€šçŸ¥çš„ä¾‹å­ï¼Œä»£ç å±•ç¤ºäº†å®¢æˆ·ç«¯å¦‚ä½•è·å–0 å·æ•°æ®åº“ä¸­æ‰€æœ‰æ‰§è¡ŒDEL å‘½ä»¤çš„é”®:

```
127.0 . 0.1:6379> SUBSCRIBE_ _keyevent@0_ _:de1
Reading messages. . . (press Ctrl-C to quit)
1) "subcribe"                      //è®¢é˜…ä¿¡æ¯
2) "_ _keyevent@0_ _:del"
3) (integer) 1

1) "message"                     //é”®keyæ‰§è¡Œäº†DELå‘½ä»¤
2) "keyevent@0_ _:del"
3) "key"

1) "message"                     //é”®numberæ‰§è¡Œäº†DELå‘½ä»¤
2) "_ _keyevent@0_ _:del"
3) "number"

1) "message"                     //é”®messageæ‰§è¡Œäº†DELå‘½ä»¤
2) "keyevent@0_ _:del"
3) "message"

```

### scan éå†
SCAN å‘½ä»¤æ˜¯ä¸€ä¸ªåŸºäºæ¸¸æ ‡çš„è¿­ä»£å™¨ï¼ˆcursor based iteratorï¼‰ï¼š SCAN å‘½ä»¤æ¯æ¬¡è¢«è°ƒç”¨ä¹‹åï¼Œ éƒ½ä¼šå‘ç”¨æˆ·è¿”å›ä¸€ä¸ªæ–°çš„æ¸¸æ ‡ï¼Œ ç”¨æˆ·åœ¨ä¸‹æ¬¡è¿­ä»£æ—¶éœ€è¦ä½¿ç”¨è¿™ä¸ªæ–°æ¸¸æ ‡ä½œä¸º SCAN å‘½ä»¤çš„æ¸¸æ ‡å‚æ•°ï¼Œ ä»¥æ­¤æ¥å»¶ç»­ä¹‹å‰çš„è¿­ä»£è¿‡ç¨‹ã€‚

å½“ SCAN å‘½ä»¤çš„æ¸¸æ ‡å‚æ•°è¢«è®¾ç½®ä¸º 0 æ—¶ï¼Œ æœåŠ¡å™¨å°†å¼€å§‹ä¸€æ¬¡æ–°çš„è¿­ä»£ï¼Œ è€Œå½“æœåŠ¡å™¨å‘ç”¨æˆ·è¿”å›å€¼ä¸º 0 çš„æ¸¸æ ‡æ—¶ï¼Œ è¡¨ç¤ºè¿­ä»£å·²ç»“æŸã€‚

### keys å‘½ä»¤

Returns all keys matching pattern.  Redis running on an entry level laptop can scan a 1 million key database in 40 milliseconds.

Warning: consider KEYS as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don't use KEYS in your regular application code. If you're looking for a way to find keys in a subset of your keyspace, consider using SCAN or sets.

### xadd å‘½ä»¤

XADD key ID field string [field string ...]

### zset ä¸skiplist æ•°æ®ç»“æ„

```C
/* ZSETs use a specialized version of Skiplists */
typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;

typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
```

### skiplist å®ç°zset

[åŸæ–‡](https://blog.csdn.net/weixin_41462047/article/details/81253106)

å¬åˆ°è·³è¡¨ï¼ˆskiplistï¼‰è¿™ä¸ªåå­—ï¼Œæ—¢ç„¶æ˜¯listï¼Œé‚£ä¹ˆåº”è¯¥è·Ÿé“¾è¡¨æœ‰å…³ã€‚ 
è·³è¡¨æ˜¯æœ‰åºé“¾è¡¨ï¼Œä½†æ˜¯æˆ‘ä»¬çŸ¥é“ï¼Œå³ä½¿å¯¹äºæ’è¿‡åºçš„é“¾è¡¨ï¼Œæˆ‘ä»¬å¯¹äºæŸ¥æ‰¾è¿˜æ˜¯éœ€è¦è¿›è¡Œé€šè¿‡é“¾è¡¨çš„æŒ‡é’ˆè¿›è¡Œéå†çš„ï¼Œæ—¶é—´å¤æ‚åº¦å¾ˆé«˜ä¾ç„¶æ˜¯O(n)ï¼Œè¿™ä¸ªæ˜¾ç„¶æ˜¯ä¸èƒ½æ¥å—çš„ã€‚æ˜¯å¦å¯ä»¥åƒæ•°ç»„é‚£æ ·ï¼Œé€šè¿‡äºŒåˆ†æ³•è¿›è¡ŒæŸ¥æ‰¾å‘¢ï¼Œä½†æ˜¯ç”±äºåœ¨å†…å­˜ä¸­çš„å­˜å‚¨çš„ä¸ç¡®å®šæ€§ï¼Œä¸èƒ½è¿™åšã€‚

ä½†æ˜¯æˆ‘ä»¬å¯ä»¥ç»“åˆäºŒåˆ†æ³•çš„æ€æƒ³ï¼Œæ²¡é”™ï¼Œè·³è¡¨å°±æ˜¯é“¾è¡¨ä¸äºŒåˆ†æ³•çš„ç»“åˆã€‚ 
1.é“¾è¡¨ä»å¤´èŠ‚ç‚¹åˆ°å°¾èŠ‚ç‚¹éƒ½æ˜¯æœ‰åºçš„ 
2.å¯ä»¥è¿›è¡Œè·³è·ƒæŸ¥æ‰¾ï¼ˆå½¢å¦‚äºŒåˆ†æ³•ï¼‰ï¼Œé™ä½æ—¶é—´å¤æ‚åº¦

ä¸€ä¸ªæœ‰åºçš„é“¾è¡¨ï¼Œæˆ‘ä»¬é€‰å–å®ƒçš„ä¸€åŠçš„èŠ‚ç‚¹ç”¨æ¥å»ºç´¢å¼•ï¼Œè¿™æ ·å¦‚æœæ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬æ¯”è¾ƒçš„æ¬¡æ•°å°±å‡å°‘äº†ä¸€åŠã€‚è¿™ç§åšæ³•ï¼Œè™½ç„¶å¢åŠ äº†50%çš„ç©ºé—´ï¼Œä½†æ˜¯æ€§èƒ½æé«˜äº†ä¸€å€ã€‚å¦‚ä¸Šå›¾ã€‚

æ—¢ç„¶ï¼Œæˆ‘ä»¬å·²ç»æå–äº†ä¸€å±‚èŠ‚ç‚¹ç´¢å¼•ï¼Œé‚£ä¹ˆï¼Œå¯ä»¥åœ¨ç¬¬ä¸€å±‚ç´¢å¼•ä¸Šå†æå–ç´¢å¼•ã€‚å¦‚ä¸‹å›¾ã€‚

#### æŸ¥è¯¢

å½“targetNode->next[i]çš„å€¼ < å¾…æŸ¥æ‰¾çš„å€¼æ—¶ï¼Œä»¤targetNode = targetNode->next[i]ï¼ŒtargetNodeç§»åˆ°ç¬¬içº§çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼› 
å½“targetNode->next[i]çš„å€¼ > å¾…æŸ¥æ‰¾çš„å€¼æ—¶ï¼Œå‘ä¸‹é™çº§ï¼Œi- - ï¼Œä¸æ”¹å˜targetNodeï¼› 
å½“targetNode->next[i]çš„å€¼ = å¾…æŸ¥æ‰¾çš„å€¼æ—¶ï¼Œå‘ä¸‹é™çº§ï¼Œi- - ï¼Œä¸æ”¹å˜targetNodeã€‚

æœ€åï¼Œå†æ¬¡æ¯”è¾ƒtargetNode->next[0]å’ŒtheElementï¼Œåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°ã€‚ 
æ‰€ä»¥æ•´ä¸ªè¿ç®—ä¸‹æ¥ï¼ŒtargetNodeæ˜¯è¦æŸ¥æ‰¾çš„èŠ‚ç‚¹å‰é¢é‚£ä¸ªèŠ‚ç‚¹ã€‚

#### æ’å…¥ 
å½“æœ‰2çº§ç´¢å¼•æ—¶ï¼Œæ–°çš„èŠ‚ç‚¹å…ˆå’Œ2çº§ç´¢å¼•æ¯”è¾ƒï¼Œå†å’Œ1çº§ç´¢å¼•æ¯”è¾ƒï¼Œæœ€åå’ŒåŸé“¾è¡¨æ¯”è¾ƒï¼Œæœ€ç»ˆæ’åˆ°åŸé“¾è¡¨ä¸­ã€‚å½“èŠ‚ç‚¹å¾ˆå¤šæ—¶ï¼Œæ¯”è¾ƒæ¬¡æ•°æ˜¯åŸæ¥çš„å››åˆ†ä¹‹ä¸€ã€‚

å½“ç„¶ï¼Œå½“èŠ‚ç‚¹è¶³å¤Ÿå¤šçš„æ—¶å€™ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç»§ç»­åŠ ç´¢å¼•ï¼Œä¿è¯æ¯ä¸€å±‚ç´¢å¼•æ•°æ˜¯ä½çº§ç´¢å¼•çš„ä¸€åŠã€‚å½“è¿™ä¸€å±‚åªå‰©ä¸¤ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå°±æ²¡æœ‰å¿…è¦å†å»ºç´¢å¼•äº†ï¼Œå› ä¸ºä¸€ä¸ªèŠ‚ç‚¹æ²¡æœ‰æ¯”è¾ƒçš„æ„ä¹‰ã€‚

å½“å¾ˆå¤šèŠ‚ç‚¹æ’å…¥æ—¶ï¼Œä¸Šå±‚ç´¢å¼•èŠ‚ç‚¹å·²ç»ä¸å¤Ÿç”¨ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ–°èŠ‚ç‚¹ä¸­é€‰å–ä¸€éƒ¨åˆ†èŠ‚ç‚¹æåˆ°ä¸Šä¸€å±‚ï¼Œè·³è¡¨çš„è®¾è®¡è€…ç”¨â€œæŠ›ç¡¬å¸â€çš„æ–¹æ³•é€‰å–èŠ‚ç‚¹æ˜¯å¦ææ‹”ï¼Œä¹Ÿå°±æ˜¯éšæœºçš„æ–¹å¼ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰50%æ¦‚ç‡ä¼šææ‹”ã€‚è¿™æ ·è™½ç„¶ä¸ä¼šè®©ç´¢å¼•ç»å¯¹å‡åŒ€åˆ†å¸ƒï¼Œä½†ä¹Ÿä¼šå¤§ä½“ä¸Šæ˜¯å‡åŒ€çš„ã€‚

ç»¼ä¸Š,æ’å…¥çš„æ­¥éª¤ï¼š

æ–°èŠ‚ç‚¹å’Œå„å±‚ç´¢å¼•èŠ‚ç‚¹é€ä¸€æ¯”è¾ƒï¼Œç¡®å®šåŸé“¾è¡¨çš„æ’å…¥ä½ç½®ã€‚Oï¼ˆlogNï¼‰
æŠŠç´¢å¼•æ’å…¥åˆ°åŸé“¾è¡¨ã€‚Oï¼ˆ1ï¼‰
åˆ©ç”¨æŠ›ç¡¬å¸çš„éšæœºæ–¹å¼ï¼Œå†³å®šæ–°èŠ‚ç‚¹æ˜¯å¦æå‡ä¸ºä¸Šä¸€çº§ç´¢å¼•ã€‚ç»“æœä¸ºâ€œæ­£â€åˆ™æå‡å¹¶ç»§ç»­æŠ›ç¡¬å¸ï¼Œç»“æœä¸ºâ€œè´Ÿâ€åˆ™åœæ­¢ã€‚Oï¼ˆlogNï¼‰
æ€»ä½“ä¸Šï¼Œè·³è¡¨æ’å…¥æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯Oï¼ˆlogNï¼‰ï¼Œè€Œè¿™ç§æ•°æ®ç»“æ„æ‰€å ç©ºé—´æ˜¯2Nï¼Œæ—¢ç©ºé—´å¤æ‚åº¦æ˜¯ Oï¼ˆNï¼‰ã€‚

#### åˆ é™¤

è‡ªä¸Šè€Œä¸‹ï¼ŒæŸ¥æ‰¾ç¬¬ä¸€æ¬¡å‡ºç°èŠ‚ç‚¹çš„ç´¢å¼•ï¼Œå¹¶é€å±‚æ‰¾åˆ°æ¯ä¸€å±‚å¯¹åº”çš„èŠ‚ç‚¹ã€‚Oï¼ˆlogNï¼‰
åˆ é™¤æ¯ä¸€å±‚æŸ¥æ‰¾åˆ°çš„èŠ‚ç‚¹ï¼Œå¦‚æœè¯¥å±‚åªå‰©ä¸‹1ä¸ªèŠ‚ç‚¹ï¼Œåˆ é™¤æ•´ä¸ªä¸€å±‚ï¼ˆåŸé“¾è¡¨é™¤å¤–ï¼‰ã€‚Oï¼ˆlogNï¼‰
æ€»ä½“ä¸Šï¼Œè·³è¡¨åˆ é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯Oï¼ˆNï¼‰ã€‚

#### åº”ç”¨ 
Rediså½“ä¸­çš„Sorted-setè¿™ç§æœ‰åºçš„é›†åˆï¼Œæ­£æ˜¯å¯¹äºè·³è¡¨çš„æ”¹è¿›å’Œåº”ç”¨ã€‚

ç›¸æ¯”äºäºŒå‰æŸ¥æ‰¾æ ‘ï¼Œè·³è¡¨ç»´æŒç»“æ„å¹³è¡¡çš„æˆæœ¬æ¯”è¾ƒä½ï¼Œå®Œå…¨é éšæœºã€‚è€ŒäºŒå‰æŸ¥æ‰¾æ ‘éœ€è¦Rebalanceæ¥é‡æ–°è°ƒæ•´å¹³è¡¡çš„ç»“æ„ã€‚ 

#### ç›¸æ¯”hash å’Œçº¢é»‘æ ‘ä¼˜ç‚¹

å¦‚æœè¦å®ç°ä¸€ä¸ªkey-valueç»“æ„ï¼Œéœ€æ±‚çš„åŠŸèƒ½æœ‰æ’å…¥ã€æŸ¥æ‰¾ã€è¿­ä»£ã€ä¿®æ”¹ï¼Œé‚£ä¹ˆé¦–å…ˆHashè¡¨å°±ä¸æ˜¯å¾ˆé€‚åˆäº†ï¼Œå› ä¸ºè¿­ä»£çš„æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒé«˜ï¼›è€Œçº¢é»‘æ ‘çš„æ’å…¥å¾ˆå¯èƒ½ä¼šæ¶‰åŠå¤šä¸ªç»“ç‚¹çš„æ—‹è½¬ã€å˜è‰²æ“ä½œï¼Œå› æ­¤éœ€è¦åœ¨å¤–å±‚åŠ é”ï¼Œè¿™æ— å½¢ä¸­é™ä½äº†å®ƒå¯èƒ½çš„å¹¶å‘åº¦ã€‚è€ŒSkipListåº•å±‚æ˜¯ç”¨é“¾è¡¨å®ç°çš„ï¼Œå¯ä»¥å®ç°ä¸ºlock freeï¼ŒåŒæ—¶å®ƒè¿˜æœ‰ç€ä¸é”™çš„æ€§èƒ½ï¼ˆå•çº¿ç¨‹ä¸‹åªæ¯”çº¢é»‘æ ‘ç•¥æ…¢ï¼‰ï¼Œéå¸¸é€‚åˆç”¨æ¥å®ç°æˆ‘ä»¬éœ€æ±‚çš„é‚£ç§key-valueç»“æ„ã€‚

### zrangebyscore

ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]

```shell
Parse the min-max interval. If one of the values is prefixed
by the "(" character, it's considered "open". For instance
ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max
ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max */


127.0.0.1:6379[1]> ZRANGEBYSCORE za 8 (8.1 limit 0 10
1) "first"
2) "s"
127.0.0.1:6379[1]> ZRANGEBYSCORE za 8 9 limit 0 10
1) "first"
2) "s"
3) "s2"
4) "s3"
127.0.0.1:6379[1]> ZRANGEBYSCORE za 8 9 limit 0 10 withscores
1) "first"
2) "8.0800000000000001"
3) "s"
4) "8.0899999999999999"
5) "s2"
6) "8.0999999999999996"
7) "s3"
8) "8.1099999999999994"
```

### setbit

SETBIT key offset value

Sets or clears the bit at offset in the string value stored at key.

The bit is either set or cleared depending on value, which can be either 0 or 1. When key does not exist, a new string value is created. The string is grown to make sure it can hold a bit at offset. The offset argument is required to be greater than or equal to 0, and smaller than 232 (this limits bitmaps to 512MB). When the string at key is grown, added bits are set to 0.

```C
//æ ¸å¿ƒä»£ç 
/* SETBIT key offset bitvalue */
void setbitCommand(client *c) {
    robj *o;
    char *err = "bit is not an integer or out of range";
    size_t bitoffset;
    ssize_t byte, bit;
    int byteval, bitval;
    long on;

    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
        return;

    if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK)
        return;

    /* Bits can only be set or cleared... */
    if (on & ~1) {
        addReplyError(c,err);
        return;
    }

    if ((o = lookupStringForBitCommand(c,bitoffset)) == NULL) return;

    /* Get current values */
    byte = bitoffset >> 3;
    byteval = ((uint8_t*)o->ptr)[byte];
    bit = 7 - (bitoffset & 0x7);
    bitval = byteval & (1 << bit);

    /* Update byte with new bit value and return original value */
    byteval &= ~(1 << bit);
    byteval |= ((on & 0x1) << bit);
    ((uint8_t*)o->ptr)[byte] = byteval;
}

/* This is an helper function for commands implementations that need to write
 * bits to a string object. The command creates or pad with zeroes the string
 * so that the 'maxbit' bit can be addressed. The object is finally
 * returned. Otherwise if the key holds a wrong type NULL is returned and
 * an error is sent to the client. */
robj *lookupStringForBitCommand(client *c, size_t maxbit) {
    size_t byte = maxbit >> 3;
    robj *o = lookupKeyWrite(c->db,c->argv[1]);

    if (o == NULL) {
        o = createObject(OBJ_STRING,sdsnewlen(NULL, byte+1));
        dbAdd(c->db,c->argv[1],o);
    } else {
        if (checkType(c,o,OBJ_STRING)) return NULL;
        o = dbUnshareStringValue(c->db,c->argv[1],o);
        o->ptr = sdsgrowzero(o->ptr,byte+1);
    }
    return o;
}

//å¤§æ¦‚æ€»ç»“ï¼š
// 1. å¯¹ä¼ å…¥çš„key é¦–å…ˆè¦ä¿è¯æœ‰ä¸€ä¸ªå­—ç¬¦ä¸²(redisObject / robj)å¯¹è±¡å…³è”
// 2. å†è®¡ç®—ä¸€ä¸‹byte = bitoffset >> 3 è¿™ä¸ªå€¼ï¼Œå¦‚100 çš„äºŒè¿›åˆ¶ä¸º01100100ï¼Œåˆ™byte ä¸º01100 = 12ã€‚
// 3. å¯¹å­—ç¬¦ä¸²å¯¹è±¡æ•°ç»„ï¼Œ12 è¿™ä¸ªä½ç½®çš„å­—èŠ‚ï¼Œå–å‡ºæ¥ï¼Œå¹¶ä¸€ä¸‹æœ¬æ¬¡ä¼ å…¥çš„bitoffset çš„ä½3 ä½æ‰©å±•åˆ°2 è¿›åˆ¶çš„å€¼ï¼Œå¦‚100 çš„ä½3 ä½ä¸º100 = 4ï¼Œæ‰€ä»¥12 è¿™ä¸ªä½ç½®ä¸Šï¼Œè¦å¹¶ä¸€ä¸‹00010000ã€‚ä»£ç æ˜¯ `byteval |= ((on & 0x1) << bit);`
// 4. æŸ¥è¯¢çš„æ—¶å€™ï¼Œå–å‡ºä½ä¸‰ä½äºŒè¿›åˆ¶è¡¨ç¤ºåçš„é‚£ä¸ªä½çš„å€¼ã€‚
```

### Redis å¸¸è§çš„æ€§èƒ½é—®é¢˜å’Œè§£å†³æ–¹æ³•

1.Masterå†™å†…å­˜å¿«ç…§ï¼Œsaveå‘½ä»¤è°ƒåº¦rdbSaveå‡½æ•°ï¼Œä¼šé˜»å¡ä¸»çº¿ç¨‹çš„å·¥ä½œï¼Œå½“å¿«ç…§æ¯”è¾ƒå¤§æ—¶å¯¹æ€§èƒ½å½±å“æ˜¯éå¸¸å¤§çš„ï¼Œä¼šé—´æ–­æ€§æš‚åœæœåŠ¡ï¼Œæ‰€ä»¥Masteræœ€å¥½ä¸è¦å†™å†…å­˜å¿«ç…§ã€‚

2.Master AOFæŒä¹…åŒ–ï¼Œå¦‚æœä¸é‡å†™AOFæ–‡ä»¶ï¼Œè¿™ä¸ªæŒä¹…åŒ–æ–¹å¼å¯¹æ€§èƒ½çš„å½±å“æ˜¯æœ€å°çš„ï¼Œä½†æ˜¯AOFæ–‡ä»¶ä¼šä¸æ–­å¢å¤§ï¼ŒAOFæ–‡ä»¶è¿‡å¤§ä¼šå½±å“Masteré‡å¯çš„æ¢å¤é€Ÿåº¦ã€‚

3.Masterè°ƒç”¨BGREWRITEAOFé‡å†™AOFæ–‡ä»¶ï¼ŒAOFåœ¨é‡å†™çš„æ—¶å€™ä¼šå å¤§é‡çš„CPUå’Œå†…å­˜èµ„æºï¼Œå¯¼è‡´æœåŠ¡loadè¿‡é«˜ï¼Œå‡ºç°çŸ­æš‚æœåŠ¡æš‚åœç°è±¡ã€‚

ä¸‹é¢æ˜¯æˆ‘çš„ä¸€ä¸ªå®é™…é¡¹ç›®çš„æƒ…å†µï¼Œå¤§æ¦‚æƒ…å†µæ˜¯è¿™æ ·çš„ï¼šä¸€ä¸ªMasterï¼Œ4ä¸ªSlaveï¼Œæ²¡æœ‰Shardingæœºåˆ¶ï¼Œä»…æ˜¯è¯»å†™åˆ†ç¦»ï¼ŒMasterè´Ÿè´£å†™å…¥æ“ä½œå’ŒAOFæ—¥å¿—å¤‡ä»½ï¼ŒAOFæ–‡ä»¶å¤§æ¦‚5Gï¼ŒSlaveè´Ÿè´£è¯»æ“ä½œï¼Œå½“Masterè°ƒç”¨BGREWRITEAOFæ—¶ï¼ŒMasterå’ŒSlaveè´Ÿè½½ä¼šçªç„¶é™¡å¢ï¼ŒMasterçš„å†™å…¥è¯·æ±‚åŸºæœ¬ä¸Šéƒ½ä¸å“åº”äº†ï¼ŒæŒç»­äº†å¤§æ¦‚5åˆ†é’Ÿï¼ŒSlaveçš„è¯»è¯·æ±‚è¿‡ä¹ŸåŠæ— æ³•åŠæ—¶å“åº”ï¼Œä¸Šé¢çš„æƒ…å†µæœ¬æ¥ä¸ä¼šä¹Ÿä¸åº”è¯¥å‘ç”Ÿçš„ï¼Œæ˜¯å› ä¸ºä»¥å‰Masterçš„è¿™ä¸ªæœºå™¨æ˜¯Slaveï¼Œåœ¨ä¸Šé¢æœ‰ä¸€ä¸ªshellå®šæ—¶ä»»åŠ¡åœ¨æ¯å¤©çš„ä¸Šåˆ10ç‚¹è°ƒç”¨BGREWRITEAOFé‡å†™AOFæ–‡ä»¶ï¼Œåæ¥ç”±äºMasteræœºå™¨downäº†ï¼Œå°±æŠŠå¤‡ä»½çš„è¿™ä¸ªSlaveåˆ‡æˆMasteräº†ï¼Œä½†æ˜¯è¿™ä¸ªå®šæ—¶ä»»åŠ¡å¿˜è®°åˆ é™¤äº†ï¼Œå°±å¯¼è‡´äº†ä¸Šé¢æ‚²å‰§æƒ…å†µçš„å‘ç”Ÿï¼ŒåŸå› è¿˜æ˜¯æ‰¾äº†å‡ å¤©æ‰æ‰¾åˆ°çš„ã€‚

å°†no-appendfsync-on-rewriteçš„é…ç½®è®¾ä¸ºyeså¯ä»¥ç¼“è§£è¿™ä¸ªé—®é¢˜ï¼Œè®¾ç½®ä¸ºyesè¡¨ç¤ºrewriteæœŸé—´å¯¹æ–°å†™æ“ä½œä¸fsyncï¼Œæš‚æ—¶å­˜åœ¨å†…å­˜ä¸­ï¼Œç­‰rewriteå®Œæˆåå†å†™å…¥ã€‚æœ€å¥½æ˜¯ä¸å¼€å¯Masterçš„AOFå¤‡ä»½åŠŸèƒ½ã€‚

4.Redisä¸»ä»å¤åˆ¶çš„æ€§èƒ½é—®é¢˜ï¼Œç¬¬ä¸€æ¬¡Slaveå‘MasteråŒæ­¥çš„å®ç°æ˜¯ï¼šSlaveå‘Masterå‘å‡ºåŒæ­¥è¯·æ±‚ï¼ŒMasterå…ˆdumpå‡ºrdbæ–‡ä»¶ï¼Œç„¶åå°†rdbæ–‡ä»¶å…¨é‡ä¼ è¾“ç»™slaveï¼Œç„¶åMasteræŠŠç¼“å­˜çš„å‘½ä»¤è½¬å‘ç»™Slaveï¼Œåˆæ¬¡åŒæ­¥å®Œæˆã€‚ç¬¬äºŒæ¬¡ä»¥åŠä»¥åçš„åŒæ­¥å®ç°æ˜¯ï¼šMasterå°†å˜é‡çš„å¿«ç…§ç›´æ¥å®æ—¶ä¾æ¬¡å‘é€ç»™å„ä¸ªSlaveã€‚ä¸ç®¡ä»€ä¹ˆåŸå› å¯¼è‡´Slaveå’ŒMasteræ–­å¼€é‡è¿éƒ½ä¼šé‡å¤ä»¥ä¸Šè¿‡ç¨‹ã€‚Redisçš„ä¸»ä»å¤åˆ¶æ˜¯å»ºç«‹åœ¨å†…å­˜å¿«ç…§çš„æŒä¹…åŒ–åŸºç¡€ä¸Šï¼Œåªè¦æœ‰Slaveå°±ä¸€å®šä¼šæœ‰å†…å­˜å¿«ç…§å‘ç”Ÿã€‚è™½ç„¶Rediså®£ç§°ä¸»ä»å¤åˆ¶æ— é˜»å¡ï¼Œä½†ç”±äºç£ç›˜ioçš„é™åˆ¶ï¼Œå¦‚æœMasterå¿«ç…§æ–‡ä»¶æ¯”è¾ƒå¤§ï¼Œé‚£ä¹ˆdumpä¼šè€—è´¹æ¯”è¾ƒé•¿çš„æ—¶é—´ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­Masterå¯èƒ½æ— æ³•å“åº”è¯·æ±‚ï¼Œä¹Ÿå°±æ˜¯è¯´æœåŠ¡ä¼šä¸­æ–­ï¼Œå¯¹äºå…³é”®æœåŠ¡ï¼Œè¿™ä¸ªåæœä¹Ÿæ˜¯å¾ˆå¯æ€•çš„ã€‚

ä»¥ä¸Š1.2.3.4æ ¹æœ¬é—®é¢˜çš„åŸå› éƒ½ç¦»ä¸å¼€ç³»ç»Ÿioç“¶é¢ˆé—®é¢˜ï¼Œä¹Ÿå°±æ˜¯ç¡¬ç›˜è¯»å†™é€Ÿåº¦ä¸å¤Ÿå¿«ï¼Œä¸»è¿›ç¨‹ fsync()/write() æ“ä½œè¢«é˜»å¡ã€‚

5.å•ç‚¹æ•…éšœé—®é¢˜ï¼Œç”±äºç›®å‰Redisçš„ä¸»ä»å¤åˆ¶è¿˜ä¸å¤Ÿæˆç†Ÿï¼Œæ‰€ä»¥å­˜åœ¨æ˜æ˜¾çš„å•ç‚¹æ•…éšœé—®é¢˜ï¼Œè¿™ä¸ªç›®å‰åªèƒ½è‡ªå·±åšæ–¹æ¡ˆè§£å†³ï¼Œå¦‚ï¼šä¸»åŠ¨å¤åˆ¶ï¼ŒProxyå®ç°Slaveå¯¹Masterçš„æ›¿æ¢ç­‰ï¼Œè¿™ä¸ªä¹Ÿæ˜¯Redisä½œè€…ç›®å‰æ¯”è¾ƒä¼˜å…ˆçš„ä»»åŠ¡ä¹‹ä¸€ï¼Œä½œè€…çš„è§£å†³æ–¹æ¡ˆæ€è·¯ç®€å•ä¼˜é›…ï¼Œè¯¦æƒ…å¯è§ Redis Sentinel design draft http://redis.io/topics/sentinel-specã€‚

 

æ€»ç»“ï¼š

1.Masteræœ€å¥½ä¸è¦åšä»»ä½•æŒä¹…åŒ–å·¥ä½œï¼ŒåŒ…æ‹¬å†…å­˜å¿«ç…§å’ŒAOFæ—¥å¿—æ–‡ä»¶ï¼Œç‰¹åˆ«æ˜¯ä¸è¦å¯ç”¨å†…å­˜å¿«ç…§åšæŒä¹…åŒ–ã€‚

2.å¦‚æœæ•°æ®æ¯”è¾ƒå…³é”®ï¼ŒæŸä¸ªSlaveå¼€å¯AOFå¤‡ä»½æ•°æ®ï¼Œç­–ç•¥ä¸ºæ¯ç§’åŒæ­¥ä¸€æ¬¡ã€‚

3.ä¸ºäº†ä¸»ä»å¤åˆ¶çš„é€Ÿåº¦å’Œè¿æ¥çš„ç¨³å®šæ€§ï¼ŒSlaveå’ŒMasteræœ€å¥½åœ¨åŒä¸€ä¸ªå±€åŸŸç½‘å†…ã€‚

4.å°½é‡é¿å…åœ¨å‹åŠ›è¾ƒå¤§çš„ä¸»åº“ä¸Šå¢åŠ ä»åº“

5.ä¸ºäº†Masterçš„ç¨³å®šæ€§ï¼Œä¸»ä»å¤åˆ¶ä¸è¦ç”¨å›¾çŠ¶ç»“æ„ï¼Œç”¨å•å‘é“¾è¡¨ç»“æ„æ›´ç¨³å®šï¼Œå³ä¸»ä»å…³ç³»ä¸ºï¼š`Master<--Slave1<--Slave2<--Slave3.......`ï¼Œè¿™æ ·çš„ç»“æ„ä¹Ÿæ–¹ä¾¿è§£å†³å•ç‚¹æ•…éšœé—®é¢˜ï¼Œå®ç°Slaveå¯¹Masterçš„æ›¿æ¢ï¼Œä¹Ÿå³ï¼Œå¦‚æœMasteræŒ‚äº†ï¼Œå¯ä»¥ç«‹é©¬å¯ç”¨Slave1åšMasterï¼Œå…¶ä»–ä¸å˜ã€‚

### å¯¹æ¯”redis å’Œmemcache ï¼ˆéå¸¸é‡è¦ï¼‰

[åŸæ–‡](https://www.cnblogs.com/JavaBlackHole/p/7726195.html)

ç»¼åˆç»“è®º

åº”è¯¥è¯´Memcachedå’ŒRediséƒ½èƒ½å¾ˆå¥½çš„æ»¡è¶³è§£å†³æˆ‘ä»¬çš„é—®é¢˜ï¼Œå®ƒä»¬æ€§èƒ½éƒ½å¾ˆé«˜ï¼Œæ€»çš„æ¥è¯´ï¼Œå¯ä»¥æŠŠRedisç†è§£ä¸ºæ˜¯å¯¹Memcachedçš„æ‹“å±•ï¼Œæ˜¯æ›´åŠ é‡é‡çº§çš„å®ç°ï¼Œæä¾›äº†æ›´å¤šæ›´å¼ºå¤§çš„åŠŸèƒ½ã€‚å…·ä½“æ¥è¯´ï¼š

1.æ€§èƒ½ä¸Šï¼š 
æ€§èƒ½ä¸Šéƒ½å¾ˆå‡ºè‰²ï¼Œå…·ä½“åˆ°ç»†èŠ‚ï¼Œç”±äºRedisåªä½¿ç”¨å•æ ¸ï¼Œè€ŒMemcachedå¯ä»¥ä½¿ç”¨å¤šæ ¸ï¼Œæ‰€ä»¥å¹³å‡æ¯ä¸€ä¸ªæ ¸ä¸ŠRedisåœ¨å­˜å‚¨å°æ•°æ®æ—¶æ¯” 
Memcachedæ€§èƒ½æ›´é«˜ã€‚è€Œåœ¨100kä»¥ä¸Šçš„æ•°æ®ä¸­ï¼ŒMemcachedæ€§èƒ½è¦é«˜äºRedisï¼Œè™½ç„¶Redisæœ€è¿‘ä¹Ÿåœ¨å­˜å‚¨å¤§æ•°æ®çš„æ€§èƒ½ä¸Šè¿›è¡Œä¼˜åŒ–ï¼Œä½†æ˜¯æ¯”èµ· Memcachedï¼Œè¿˜æ˜¯ç¨æœ‰é€Šè‰²ã€‚

2.å†…å­˜ç©ºé—´å’Œæ•°æ®é‡å¤§å°ï¼š 
MemCachedå¯ä»¥ä¿®æ”¹æœ€å¤§å†…å­˜ï¼Œé‡‡ç”¨LRUç®—æ³•ã€‚Rediså¢åŠ äº†VMçš„ç‰¹æ€§ï¼Œçªç ´äº†ç‰©ç†å†…å­˜çš„é™åˆ¶ã€‚

3.æ“ä½œä¾¿åˆ©ä¸Šï¼š 
MemCachedæ•°æ®ç»“æ„å•ä¸€ï¼Œä»…ç”¨æ¥ç¼“å­˜æ•°æ®ï¼Œè€ŒRedisæ”¯æŒæ›´åŠ ä¸°å¯Œçš„æ•°æ®ç±»å‹ï¼Œä¹Ÿå¯ä»¥åœ¨æœåŠ¡å™¨ç«¯ç›´æ¥å¯¹æ•°æ®è¿›è¡Œä¸°å¯Œçš„æ“ä½œ,è¿™æ ·å¯ä»¥å‡å°‘ç½‘ç»œIOæ¬¡æ•°å’Œæ•°æ®ä½“ç§¯ã€‚

4.å¯é æ€§ä¸Šï¼š 
MemCachedä¸æ”¯æŒæ•°æ®æŒä¹…åŒ–ï¼Œæ–­ç”µæˆ–é‡å¯åæ•°æ®æ¶ˆå¤±ï¼Œä½†å…¶ç¨³å®šæ€§æ˜¯æœ‰ä¿è¯çš„ã€‚Redisæ”¯æŒæ•°æ®æŒä¹…åŒ–å’Œæ•°æ®æ¢å¤ï¼Œå…è®¸å•ç‚¹æ•…éšœï¼Œä½†æ˜¯åŒæ—¶ä¹Ÿä¼šä»˜å‡ºæ€§èƒ½çš„ä»£ä»·ã€‚

5.åº”ç”¨åœºæ™¯ï¼š 
Memcachedï¼šåŠ¨æ€ç³»ç»Ÿä¸­å‡è½»æ•°æ®åº“è´Ÿè½½ï¼Œæå‡æ€§èƒ½ï¼›åšç¼“å­˜ï¼Œé€‚åˆå¤šè¯»å°‘å†™ï¼Œå¤§æ•°æ®é‡çš„æƒ…å†µï¼ˆå¦‚äººäººç½‘å¤§é‡æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯ã€å¥½å‹ä¿¡æ¯ã€æ–‡ç« ä¿¡æ¯ç­‰ï¼‰ã€‚ 
Redisï¼šé€‚ç”¨äºå¯¹è¯»å†™æ•ˆç‡è¦æ±‚éƒ½å¾ˆé«˜ï¼Œæ•°æ®å¤„ç†ä¸šåŠ¡å¤æ‚å’Œå¯¹å®‰å…¨æ€§è¦æ±‚è¾ƒé«˜çš„ç³»ç»Ÿï¼ˆå¦‚æ–°æµªå¾®åšçš„è®¡æ•°å’Œå¾®åšå‘å¸ƒéƒ¨åˆ†ç³»ç»Ÿï¼Œå¯¹æ•°æ®å®‰å…¨æ€§ã€è¯»å†™è¦æ±‚éƒ½å¾ˆé«˜ï¼‰ã€‚

éœ€è¦æ…é‡è€ƒè™‘çš„éƒ¨åˆ† 
1.Memcachedå•ä¸ªkey-valueå¤§å°æœ‰é™ï¼Œä¸€ä¸ªvalueæœ€å¤§åªæ”¯æŒ1MBï¼Œè€ŒRedisæœ€å¤§æ”¯æŒ512MB 
2.Memcachedåªæ˜¯ä¸ªå†…å­˜ç¼“å­˜ï¼Œå¯¹å¯é æ€§æ— è¦æ±‚ï¼›è€ŒRedisæ›´å€¾å‘äºå†…å­˜æ•°æ®åº“ï¼Œå› æ­¤å¯¹å¯¹å¯é æ€§æ–¹é¢è¦æ±‚æ¯”è¾ƒé«˜ 
3.ä»æœ¬è´¨ä¸Šè®²ï¼ŒMemcachedåªæ˜¯ä¸€ä¸ªå•ä¸€key-valueå†…å­˜Cacheï¼›è€ŒRedisåˆ™æ˜¯ä¸€ä¸ªæ•°æ®ç»“æ„å†…å­˜æ•°æ®åº“ï¼Œæ”¯æŒäº”ç§æ•°æ®ç±»å‹ï¼Œå› æ­¤Redisé™¤å•çº¯ç¼“å­˜ä½œç”¨å¤–ï¼Œè¿˜å¯ä»¥å¤„ç†ä¸€äº›ç®€å•çš„é€»è¾‘è¿ç®—ï¼ŒRedisä¸ä»…å¯ä»¥ç¼“å­˜ï¼Œè€Œä¸”è¿˜å¯ä»¥ä½œä¸ºæ•°æ®åº“ç”¨ 
4.æ–°ç‰ˆæœ¬ï¼ˆ3.0ï¼‰çš„Redisæ˜¯æŒ‡é›†ç¾¤åˆ†å¸ƒå¼ï¼Œä¹Ÿå°±æ˜¯è¯´é›†ç¾¤æœ¬èº«å‡è¡¡å®¢æˆ·ç«¯è¯·æ±‚ï¼Œå„ä¸ªèŠ‚ç‚¹å¯ä»¥äº¤æµï¼Œå¯æ‹“å±•è¡Œã€å¯ç»´æŠ¤æ€§æ›´å¼ºå¤§ã€‚

#### è¡¥å……
åœ¨Redisä¸­ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„æ•°æ®éƒ½ä¸€ç›´å­˜å‚¨åœ¨å†…å­˜ä¸­çš„ï¼Œè¿™æ˜¯å’ŒMemcacheç›¸æ¯”ä¸€ä¸ªæœ€å¤§çš„åŒºåˆ«ä¹‹ä¸€çš„ã€‚
è¿˜æœ‰è¿™ä¸ªRedisåœ¨å¾ˆå¤šæ–¹é¢å…·å¤‡æ•°æ®åº“çš„ç‰¹å¾çš„ï¼Œæˆ–è€…è¯´å°±æ˜¯ä¸€ä¸ªæ•°æ®åº“ç³»ç»Ÿï¼Œè€ŒMemcacheåªæ˜¯ç®€å•çš„K/Vç¼“å­˜çš„ã€‚
ä»–ä»¬çš„æ‰©å±•éƒ½éœ€è¦åšé›†ç¾¤ï¼›å®ç°æ–¹å¼ï¼šmaster-slaveã€Hashçš„ã€‚ï¼Œä¸è¿‡åœ¨100kä»¥ä¸Šçš„æ•°æ®ä¸­ï¼ŒMemcacheæ€§èƒ½è¦é«˜äºRedisçš„ã€‚
å¦‚æœä½ å¯¹æ•°æ®æŒä¹…åŒ–å’Œæ•°æ®åŒæ­¥æœ‰æ‰€è¦æ±‚ï¼Œé‚£ä¹ˆæ¨èä½ é€‰æ‹©Redisçš„ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªç‰¹æ€§Memcacheéƒ½ä¸å…·å¤‡çš„ã€‚
æ‰€ä»¥å³ä½¿ä½ åªæ˜¯å¸Œæœ›åœ¨å‡çº§æˆ–è€…é‡å¯ç³»ç»Ÿåç¼“å­˜æ•°æ®ä¸ä¼šä¸¢å¤±çš„ï¼Œé€‰æ‹©Redisä¹Ÿæ˜¯æ˜æ™ºçš„é€‰æ‹©å¾—çš„ã€‚
è¿˜æœ‰è™½ç„¶è¿™ä¸ªRediså’ŒMemcacheåœ¨å†™å…¥æ€§èƒ½ä¸Šé¢å·®åˆ«ä¸å¤§çš„ï¼Œè¯»å–æ€§èƒ½ä¸Šé¢å°¤å…¶æ˜¯æ‰¹é‡è¯»å–æ€§èƒ½ä¸Šé¢Memcacheæ›´å¼ºçš„ã€‚
ä»¥ä¸ŠåŒºåˆ«è¯´æ˜ï¼šmemcacheè¿˜æ˜¯æœ‰å¯å–ä¹‹å¤„çš„ï¼ï¼ï¼
Memcacheå¯ä»¥åˆ©ç”¨å¤šæ ¸ä¼˜åŠ¿çš„ï¼Œå•å®ä¾‹ååé‡æé«˜çš„ï¼Œå¯ä»¥è¾¾åˆ°å‡ åä¸‡QPS,é€‚ç”¨äºæœ€å¤§ç¨‹åº¦æ‰›é‡çš„çš„ã€‚
ä»–çš„è¯åªæ”¯æŒç®€å•çš„key/valueæ•°æ®ç»“æ„çš„ï¼Œä¸åƒRediså¯ä»¥æ”¯æŒä¸°å¯Œçš„æ•°æ®ç±»å‹çš„ã€‚
æ— æ³•è¿›è¡ŒæŒä¹…åŒ–ï¼Œæ•°æ®ä¸èƒ½å¤‡ä»½ï¼Œåªèƒ½ç”¨äºç¼“å­˜ä½¿ç”¨ï¼Œè€Œä¸”ä¸”é‡å¯åæ•°æ®å…¨éƒ¨ä¸¢å¤±çš„

### redis å¸¸è§35 é—®é¢˜
[åŸæ–‡](https://blog.csdn.net/chinahuyong/article/details/82683155)

### redis watch 

[åŸæ–‡](https://www.jianshu.com/p/ad273642b3bb)
æˆ‘ä»¬å¸¸ç”¨redisçš„watchå’Œmultiæ¥å¤„ç†ä¸€äº›æ¶‰åŠå¹¶å‘çš„æ“ä½œï¼Œredisçš„watch+multiå®é™…æ˜¯ä¸€ç§ä¹è§‚é”ï¼Œä»Šå¤©æˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹å®ƒçš„å®ç°æœºåˆ¶ã€‚

```
$key = 'xxxx';
$redis->watch($key);
$redis->multi();
// æ›´æ–°äº†key
$redis->set($key);
$flag = $redis->exec();

// å¦‚æœäº‹åŠ¡æ‰§è¡Œå¤±è´¥è¿”å›false
if ($flag === false) {
    
} else {
    
}
```
å½“å®¢æˆ·ç«¯Aå’Œå®¢æˆ·ç«¯BåŒæ—¶æ‰§è¡Œè¿™æ®µä»£ç æ—¶å€™ï¼Œå› ä¸ºäº‹åŠ¡çš„æ‰§è¡Œæ˜¯ä¸²è¡Œçš„ï¼Œå‡è®¾Aå®¢æˆ·ç«¯å…ˆäºBæ‰§è¡Œï¼Œé‚£ä¹ˆå½“Aæ‰§è¡Œå®Œæˆæ—¶ï¼Œä¼šå°†å®¢æˆ·ç«¯Aä»watchäº†è¿™ä¸ªkeyçš„åˆ—è¡¨ä¸­åˆ é™¤ï¼Œå¹¶ä¸”å°†åˆ—è¡¨ä¸­çš„æ‰€æœ‰å®¢æˆ·ç«¯éƒ½è®¾ç½®ä¸ºCLIENT_DIRTY_CASï¼Œä¹‹åå½“Bæ‰§è¡Œçš„æ—¶å€™ï¼Œäº‹åŠ¡å‘ç°Bçš„çŠ¶æ€æ˜¯CLIENT_DIRTY_CASï¼Œä¾¿ç»ˆæ­¢äº‹åŠ¡å¹¶è¿”å›å¤±è´¥ã€‚

```shell
127.0.0.1:6379[1]> watch test2
OK
127.0.0.1:6379[1]> multi
OK
127.0.0.1:6379[1]> incr test2
QUEUED
127.0.0.1:6379[1]> exec
1) (integer) 7
127.0.0.1:6379[1]> watch test2
OK
127.0.0.1:6379[1]> multi
OK
127.0.0.1:6379[1]> incr test2
QUEUED
127.0.0.1:6379[1]> exec
(nil)
127.0.0.1:6379[1]>
```
ä»£ç ï¼š
```c
/* exec å‘½ä»¤ */
void execCommand(client *c) {
    int j;
    robj **orig_argv;
    int orig_argc;
    struct redisCommand *orig_cmd;
    int must_propagate = 0; /* Need to propagate MULTI/EXEC to AOF / slaves? */
    int was_master = server.masterhost == NULL;
    
    // æœªæ‰§è¡Œmultiï¼Œåˆ™è¿”å›
    if (!(c->flags & CLIENT_MULTI)) {
        addReplyError(c,"EXEC without MULTI");
        return;
    }
    
    /*
     * å…³é”®
     * å¤„ç†å®¢æˆ·ç«¯çŠ¶æ€ ä»¥ä¸‹ä¸¤ç§çŠ¶æ€ä¼šç›´æ¥ç»ˆæ­¢äº‹åŠ¡ï¼Œä¸ä¼šæ‰§è¡Œäº‹åŠ¡é˜Ÿåˆ—ä¸­çš„å‘½ä»¤
     * 1. CLIENT_DIRTY_CAS => å½“å› ä¸ºwatchçš„keyè¢«touchäº†
     * 2. CLIENT_DIRTY_EXEC => å½“å®¢æˆ·ç«¯å…¥é˜Ÿäº†ä¸å­˜åœ¨çš„å‘½ä»¤
     */
    
    /* Check if we need to abort the EXEC because:
     * 1) Some WATCHed key was touched.
     * 2) There was a previous error while queueing commands.
     * A failed EXEC in the first case returns a multi bulk nil object
     * (technically it is not an error but a special behavior), while
     * in the second an EXECABORT error is returned. */
    if (c->flags & (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC)) {
        addReply(c, c->flags & CLIENT_DIRTY_EXEC ? shared.execaborterr :
                                                  shared.nullmultibulk);
        // 
        discardTransaction(c);
        goto handle_monitor;
    }

    /* æ‰§è¡Œé˜Ÿåˆ—ä¸­çš„å‘½ä»¤ */
    // æ¸…ç©ºå½“å‰å®¢æˆ·ç«¯ä¸­å­˜å‚¨çš„watchäº†çš„keyï¼Œå’Œhashè¡¨ä¸­å®¢æˆ·ç«¯node
    unwatchAllKeys(c); /* Unwatch ASAP otherwise we'll waste CPU cycles */
    orig_argv = c->argv;
    orig_argc = c->argc;
    orig_cmd = c->cmd;
    addReplyMultiBulkLen(c,c->mstate.count);
    // æ‰§è¡Œé˜Ÿåˆ—ä¸­çš„å‘½ä»¤
    for (j = 0; j < c->mstate.count; j++) {
    }
}
```

åœ¨set ä¸€äº›å€¼çš„æ—¶å€™ï¼Œä¼šæŠŠflag æ ‡è¯†ä¸ºCLIENT_DIRDY_CAS
```c
void setKey(redisDb *db, robj *key, robj *val) {
    if (lookupKeyWrite(db,key) == NULL) {
        dbAdd(db,key,val);
    } else {
        dbOverwrite(db,key,val);
    }
    incrRefCount(val);
    removeExpire(db,key);
    // çœ‹è¿™é‡ŒğŸ‘€ æ ‡è®°hashè¡¨ä¸­æ‰€æœ‰å·²ç»watchè¿™ä¸ªkeyçš„æ‰€æœ‰å®¢æˆ·ç«¯çŠ¶æ€ä¸ºCLIENT_DIRTY_CAS
    // å¦‚æœæˆ‘åŸå…ˆçš„å€¼ä¸º1ï¼Œè¿™é‡Œsetä¸º1ï¼Œä¹Ÿä¼šæ‰§è¡Œè¿™ä¸ªæ–¹æ³•ã€‚æ‰€ä»¥è¯´å’Œå€¼å˜æ²¡å˜æ²¡å…³ç³»ã€‚
    signalModifiedKey(db,key);
}

void signalModifiedKey(redisDb *db, robj *key) {
    touchWatchedKey(db,key);
}

/* æ›´æ–°hashè¡¨ä¸­ç›¸åº”å®¢æˆ·ç«¯çš„çŠ¶æ€ä¸ºCLIENT_DIRTY_CAS */
void touchWatchedKey(redisDb *db, robj *key) {
    list *clients;
    listIter li;
    listNode *ln;

    if (dictSize(db->watched_keys) == 0) return;
    clients = dictFetchValue(db->watched_keys, key);
    if (!clients) return;

    /* Mark all the clients watching this key as CLIENT_DIRTY_CAS */
    /* Check if we are already watching for this key */
    listRewind(clients,&li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);

        c->flags |= CLIENT_DIRTY_CAS;
    }
}
```

### Redisä¸ºä»€ä¹ˆè¿™ä¹ˆå¿«

1ã€å®Œå…¨åŸºäºå†…å­˜ï¼Œç»å¤§éƒ¨åˆ†è¯·æ±‚æ˜¯çº¯ç²¹çš„å†…å­˜æ“ä½œï¼Œéå¸¸å¿«é€Ÿã€‚æ•°æ®å­˜åœ¨å†…å­˜ä¸­ï¼Œç±»ä¼¼äºHashMapï¼ŒHashMapçš„ä¼˜åŠ¿å°±æ˜¯æŸ¥æ‰¾å’Œæ“ä½œçš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(1)ï¼›

2ã€æ•°æ®ç»“æ„ç®€å•ï¼Œå¯¹æ•°æ®æ“ä½œä¹Ÿç®€å•ï¼ŒRedisä¸­çš„æ•°æ®ç»“æ„æ˜¯ä¸“é—¨è¿›è¡Œè®¾è®¡çš„ï¼›

3ã€é‡‡ç”¨å•çº¿ç¨‹ï¼Œé¿å…äº†ä¸å¿…è¦çš„ä¸Šä¸‹æ–‡åˆ‡æ¢å’Œç«äº‰æ¡ä»¶ï¼Œä¹Ÿä¸å­˜åœ¨å¤šè¿›ç¨‹æˆ–è€…å¤šçº¿ç¨‹å¯¼è‡´çš„åˆ‡æ¢è€Œæ¶ˆè€— CPUï¼Œä¸ç”¨å»è€ƒè™‘å„ç§é”çš„é—®é¢˜ï¼Œä¸å­˜åœ¨åŠ é”é‡Šæ”¾é”æ“ä½œï¼Œæ²¡æœ‰å› ä¸ºå¯èƒ½å‡ºç°æ­»é”è€Œå¯¼è‡´çš„æ€§èƒ½æ¶ˆè€—ï¼›

4ã€ä½¿ç”¨å¤šè·¯I/Oå¤ç”¨æ¨¡å‹ï¼Œéé˜»å¡IOï¼›

5ã€ä½¿ç”¨åº•å±‚æ¨¡å‹ä¸åŒï¼Œå®ƒä»¬ä¹‹é—´åº•å±‚å®ç°æ–¹å¼ä»¥åŠä¸å®¢æˆ·ç«¯ä¹‹é—´é€šä¿¡çš„åº”ç”¨åè®®ä¸ä¸€æ ·ï¼ŒRedisç›´æ¥è‡ªå·±æ„å»ºäº†VM æœºåˆ¶ ï¼Œå› ä¸ºä¸€èˆ¬çš„ç³»ç»Ÿè°ƒç”¨ç³»ç»Ÿå‡½æ•°çš„è¯ï¼Œä¼šæµªè´¹ä¸€å®šçš„æ—¶é—´å»ç§»åŠ¨å’Œè¯·æ±‚ï¼›

ä»¥ä¸Šå‡ ç‚¹éƒ½æ¯”è¾ƒå¥½ç†è§£ï¼Œä¸‹è¾¹æˆ‘ä»¬é’ˆå¯¹å¤šè·¯ I/O å¤ç”¨æ¨¡å‹è¿›è¡Œç®€å•çš„æ¢è®¨ï¼š

ï¼ˆ1ï¼‰å¤šè·¯ I/O å¤ç”¨æ¨¡å‹

å¤šè·¯I/Oå¤ç”¨æ¨¡å‹æ˜¯åˆ©ç”¨ selectã€pollã€epoll å¯ä»¥åŒæ—¶ç›‘å¯Ÿå¤šä¸ªæµçš„ I/O äº‹ä»¶çš„èƒ½åŠ›ï¼Œåœ¨ç©ºé—²çš„æ—¶å€™ï¼Œä¼šæŠŠå½“å‰çº¿ç¨‹é˜»å¡æ‰ï¼Œå½“æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªæµæœ‰ I/O äº‹ä»¶æ—¶ï¼Œå°±ä»é˜»å¡æ€ä¸­å”¤é†’ï¼Œäºæ˜¯ç¨‹åºå°±ä¼šè½®è¯¢ä¸€éæ‰€æœ‰çš„æµï¼ˆepoll æ˜¯åªè½®è¯¢é‚£äº›çœŸæ­£å‘å‡ºäº†äº‹ä»¶çš„æµï¼‰ï¼Œå¹¶ä¸”åªä¾æ¬¡é¡ºåºçš„å¤„ç†å°±ç»ªçš„æµï¼Œè¿™ç§åšæ³•å°±é¿å…äº†å¤§é‡çš„æ— ç”¨æ“ä½œã€‚

**è¿™é‡Œâ€œå¤šè·¯â€æŒ‡çš„æ˜¯å¤šä¸ªç½‘ç»œè¿æ¥ï¼Œâ€œå¤ç”¨â€æŒ‡çš„æ˜¯å¤ç”¨åŒä¸€ä¸ªçº¿ç¨‹ã€‚**é‡‡ç”¨å¤šè·¯ I/O å¤ç”¨æŠ€æœ¯å¯ä»¥è®©å•ä¸ªçº¿ç¨‹é«˜æ•ˆçš„å¤„ç†å¤šä¸ªè¿æ¥è¯·æ±‚ï¼ˆå°½é‡å‡å°‘ç½‘ç»œ IO çš„æ—¶é—´æ¶ˆè€—ï¼‰ï¼Œä¸” Redis åœ¨å†…å­˜ä¸­æ“ä½œæ•°æ®çš„é€Ÿåº¦éå¸¸å¿«ï¼Œä¹Ÿå°±æ˜¯è¯´å†…å­˜å†…çš„æ“ä½œä¸ä¼šæˆä¸ºå½±å“Redisæ€§èƒ½çš„ç“¶é¢ˆï¼Œä¸»è¦ç”±ä»¥ä¸Šå‡ ç‚¹é€ å°±äº† Redis å…·æœ‰å¾ˆé«˜çš„ååé‡ã€‚

### é‚£ä¹ˆä¸ºä»€ä¹ˆRedisæ˜¯å•çº¿ç¨‹çš„
æˆ‘ä»¬é¦–å…ˆè¦æ˜ç™½ï¼Œä¸Šè¾¹çš„ç§ç§åˆ†æï¼Œéƒ½æ˜¯ä¸ºäº†è¥é€ ä¸€ä¸ªRediså¾ˆå¿«çš„æ°›å›´ï¼å®˜æ–¹FAQè¡¨ç¤ºï¼Œå› ä¸ºRedisæ˜¯åŸºäºå†…å­˜çš„æ“ä½œï¼ŒCPUä¸æ˜¯Redisçš„ç“¶é¢ˆï¼ŒRedisçš„ç“¶é¢ˆæœ€æœ‰å¯èƒ½æ˜¯æœºå™¨å†…å­˜çš„å¤§å°æˆ–è€…ç½‘ç»œå¸¦å®½ã€‚æ—¢ç„¶å•çº¿ç¨‹å®¹æ˜“å®ç°ï¼Œè€Œä¸”CPUä¸ä¼šæˆä¸ºç“¶é¢ˆï¼Œé‚£å°±é¡ºç†æˆç« åœ°é‡‡ç”¨å•çº¿ç¨‹çš„æ–¹æ¡ˆäº†ï¼ˆæ¯•ç«Ÿé‡‡ç”¨å¤šçº¿ç¨‹ä¼šæœ‰å¾ˆå¤šéº»çƒ¦ï¼ï¼‰ã€‚

### cpu å› ç´ 
1ã€æˆ‘ä»¬çŸ¥é“Redisæ˜¯ç”¨"å•çº¿ç¨‹-å¤šè·¯å¤ç”¨IOæ¨¡å‹"æ¥å®ç°é«˜æ€§èƒ½çš„å†…å­˜æ•°æ®æœåŠ¡çš„ï¼Œè¿™ç§æœºåˆ¶é¿å…äº†ä½¿ç”¨é”ï¼Œä½†æ˜¯åŒæ—¶è¿™ç§æœºåˆ¶åœ¨è¿›è¡Œsunionä¹‹ç±»çš„æ¯”è¾ƒè€—æ—¶çš„å‘½ä»¤æ—¶ä¼šä½¿redisçš„å¹¶å‘ä¸‹é™ã€‚å› ä¸ºæ˜¯å•ä¸€çº¿ç¨‹ï¼Œæ‰€ä»¥åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªæ“ä½œåœ¨è¿›è¡Œï¼Œæ‰€ä»¥ï¼Œè€—æ—¶çš„å‘½ä»¤ä¼šå¯¼è‡´å¹¶å‘çš„ä¸‹é™ï¼Œä¸åªæ˜¯è¯»å¹¶å‘ï¼Œå†™å¹¶å‘ä¹Ÿä¼šä¸‹é™ã€‚è€Œå•ä¸€çº¿ç¨‹ä¹Ÿåªèƒ½ç”¨åˆ°ä¸€ä¸ªCPUæ ¸å¿ƒï¼Œæ‰€ä»¥å¯ä»¥åœ¨åŒä¸€ä¸ªå¤šæ ¸çš„æœåŠ¡å™¨ä¸­ï¼Œå¯ä»¥å¯åŠ¨å¤šä¸ªå®ä¾‹ï¼Œç»„æˆmaster-masteræˆ–è€…master-slaveçš„å½¢å¼ï¼Œè€—æ—¶çš„è¯»å‘½ä»¤å¯ä»¥å®Œå…¨åœ¨slaveè¿›è¡Œã€‚

éœ€è¦æ”¹çš„redis.confé¡¹ï¼š

pidfile /var/run/redis/redis_6377.pid  #pidfileè¦åŠ ä¸Šç«¯å£å·
port 6377  #è¿™ä¸ªæ˜¯å¿…é¡»æ”¹çš„
logfile /var/log/redis/redis_6377.log #logfileçš„åç§°ä¹ŸåŠ ä¸Šç«¯å£å·
dbfilename dump_6377.rdb  #rdbfileä¹ŸåŠ ä¸Šç«¯å£å·

2ã€â€œæˆ‘ä»¬ä¸èƒ½ä»»ç”±æ“ä½œç³»ç»Ÿè´Ÿè½½å‡è¡¡ï¼Œå› ä¸ºæˆ‘ä»¬è‡ªå·±æ›´äº†è§£è‡ªå·±çš„ç¨‹åºï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨åœ°ä¸ºå…¶åˆ†é…CPUæ ¸ï¼Œè€Œä¸ä¼šè¿‡å¤šåœ°å ç”¨CPUï¼Œæˆ–æ˜¯è®©æˆ‘ä»¬å…³é”®è¿›ç¨‹å’Œä¸€å †åˆ«çš„è¿›ç¨‹æŒ¤åœ¨ä¸€èµ·ã€‚â€ã€‚
CPU æ˜¯ä¸€ä¸ªé‡è¦çš„å½±å“å› ç´ ï¼Œç”±äºæ˜¯å•çº¿ç¨‹æ¨¡å‹ï¼ŒRedis æ›´å–œæ¬¢å¤§ç¼“å­˜å¿«é€Ÿ CPUï¼Œ è€Œä¸æ˜¯å¤šæ ¸

åœ¨å¤šæ ¸ CPU æœåŠ¡å™¨ä¸Šé¢ï¼ŒRedis çš„æ€§èƒ½è¿˜ä¾èµ–NUMA é…ç½®å’Œå¤„ç†å™¨ç»‘å®šä½ç½®ã€‚æœ€æ˜æ˜¾çš„å½±å“æ˜¯ redis-benchmark ä¼šéšæœºä½¿ç”¨CPUå†…æ ¸ã€‚ä¸ºäº†è·å¾—ç²¾å‡†çš„ç»“æœï¼Œéœ€è¦ä½¿ç”¨å›ºå®šå¤„ç†å™¨å·¥å…·ï¼ˆåœ¨ Linux ä¸Šå¯ä»¥ä½¿ç”¨ tasksetï¼‰ã€‚æœ€æœ‰æ•ˆçš„åŠæ³•æ˜¯å°†å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯åˆ†ç¦»åˆ°ä¸¤ä¸ªä¸åŒçš„ CPU æ¥é«˜æ ¡ä½¿ç”¨ä¸‰çº§ç¼“å­˜ã€‚

### å¸¸è§çº¿ç¨‹æ¨¡å‹

1ã€å•è¿›ç¨‹å¤šçº¿ç¨‹æ¨¡å‹ï¼šMySQLã€Memcachedã€Oracleï¼ˆWindowsç‰ˆæœ¬ï¼‰ï¼›

2ã€å¤šè¿›ç¨‹æ¨¡å‹ï¼šOracleï¼ˆLinuxç‰ˆæœ¬ï¼‰ï¼›

3ã€Nginxæœ‰ä¸¤ç±»è¿›ç¨‹ï¼Œä¸€ç±»ç§°ä¸ºMasterè¿›ç¨‹(ç›¸å½“äºç®¡ç†è¿›ç¨‹)ï¼Œå¦ä¸€ç±»ç§°ä¸ºWorkerè¿›ç¨‹ï¼ˆå®é™…å·¥ä½œè¿›ç¨‹ï¼‰ã€‚å¯åŠ¨æ–¹å¼æœ‰ä¸¤ç§ï¼š

ï¼ˆ1ï¼‰å•è¿›ç¨‹å¯åŠ¨ï¼šæ­¤æ—¶ç³»ç»Ÿä¸­ä»…æœ‰ä¸€ä¸ªè¿›ç¨‹ï¼Œè¯¥è¿›ç¨‹æ—¢å……å½“Masterè¿›ç¨‹çš„è§’è‰²ï¼Œä¹Ÿå……å½“Workerè¿›ç¨‹çš„è§’è‰²ã€‚

ï¼ˆ2ï¼‰å¤šè¿›ç¨‹å¯åŠ¨ï¼šæ­¤æ—¶ç³»ç»Ÿæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªMasterè¿›ç¨‹ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªWorkerè¿›ç¨‹å·¥ä½œã€‚

ï¼ˆ3ï¼‰Masterè¿›ç¨‹ä¸»è¦è¿›è¡Œä¸€äº›å…¨å±€æ€§çš„åˆå§‹åŒ–å·¥ä½œå’Œç®¡ç†Workerçš„å·¥ä½œï¼›äº‹ä»¶å¤„ç†æ˜¯åœ¨Workerä¸­è¿›è¡Œçš„ã€‚

### ä¸»ä»åŒæ­¥æ•°æ®

ä¸»ä»åŒæ­¥è½¬ç§»
é¦–å…ˆåœ¨æ–°æœåŠ¡å™¨ä¸Šç›´æ¥è¿›å…¥redis-cliï¼Œæ‰§è¡Œä»åº“é…ç½®slaveof 192.168.1.100 6379ï¼Œè¿™é‡Œå‡è®¾è¦å°†192.168.1.100çš„6379ç«¯å£çš„redisæœåŠ¡è½¬ç§»è¿‡æ¥ã€‚è¿™æ ·å°±å·²ç»å¼€å§‹åŒæ­¥äº†ã€‚é€šè¿‡infoå¯ä»¥æŸ¥çœ‹å½“å‰æœåŠ¡å™¨æ˜¯slaveã€‚

ç„¶åé€šè¿‡infoå‘½ä»¤æŸ¥çœ‹master_link_statusï¼Œå¦‚æœä¸ºupï¼Œè¡¨ç¤ºåŒæ­¥å®Œæˆã€‚ï¼ˆåœ¨åŒæ­¥è¿‡ç¨‹ä¸­ï¼Œæ‰§è¡ŒæŸ¥è¯¢çš„æ—¶å€™è¿˜æ˜¯ä¼šæç¤º"Redis is loading the dataset in memory"ï¼Œè¿™å±äºæ­£å¸¸æƒ…å†µ.æŠŠæ•°æ®ä»ç£ç›˜æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­å¯èƒ½ä¼šæ¶ˆè€—å¾ˆé•¿çš„ä¸€æ®µæ—¶é—´ã€‚ï¼‰

æœ€åæ–­å¼€ä¸»ä»å…³ç³»ï¼Œåœ¨redis-cliå‘½ä»¤è¡Œä¸‹æ‰§è¡Œslaveof no oneæç¤ºOKï¼Œå†é€šè¿‡infoæŸ¥çœ‹ï¼Œè¯¥æ–°æœåŠ¡å™¨å·²ç»è‡ªå·±å˜æˆmasteräº†ã€‚

<!-- ä½œè€…ï¼šCRUDè€ç å†œ -->
<!-- é“¾æ¥ï¼šhttps://www.jianshu.com/p/b6b77709561e -->
<!-- æ¥æºï¼šç®€ä¹¦ -->
<!-- è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ -->

### å†…å­˜è°ƒæ•´

å±æ€§å	å±æ€§è¯´æ˜
used_memory Redis	åˆ†é…å™¨åˆ†é…çš„å†…å­˜é‡ï¼Œä¹Ÿå°±æ˜¯å®é™…å­˜å‚¨æ•°æ®çš„å†…å­˜æ€»é‡
used_memory_human	ä»¥å¯è¯»æ ¼å¼è¿”å› Redis ä½¿ç”¨çš„å†…å­˜æ€»é‡
used_memory_rss	ä»æ“ä½œç³»ç»Ÿçš„è§’åº¦ï¼ŒRedisè¿›ç¨‹å ç”¨çš„æ€»ç‰©ç†å†…å­˜
used_memory_peak	å†…å­˜åˆ†é…å™¨åˆ†é…çš„æœ€å¤§å†…å­˜ï¼Œä»£è¡¨used_memoryçš„å†å²å³°å€¼
used_memory_peak_human	ä»¥å¯è¯»çš„æ ¼å¼æ˜¾ç¤ºå†…å­˜æ¶ˆè€—å³°å€¼
used_memory_lua	Luaå¼•æ“æ‰€æ¶ˆè€—çš„å†…å­˜
mem_fragmentation_ratio	used_memory_rss /used_memoryæ¯”å€¼ï¼Œè¡¨ç¤ºå†…å­˜ç¢ç‰‡ç‡
mem_allocator	Redis æ‰€ä½¿ç”¨çš„å†…å­˜åˆ†é…å™¨ã€‚é»˜è®¤: jemalloc

ratioæŒ‡æ•°`>1`è¡¨æ˜æœ‰å†…å­˜ç¢ç‰‡ï¼Œè¶Šå¤§è¡¨æ˜è¶Šå¤šï¼Œ`<1`è¡¨æ˜æ­£åœ¨ä½¿ç”¨è™šæ‹Ÿå†…å­˜ï¼Œè™šæ‹Ÿå†…å­˜å…¶å®å°±æ˜¯ç¡¬ç›˜ï¼Œæ€§èƒ½æ¯”å†…å­˜ä½å¾—å¤šï¼Œè¿™æ˜¯åº”è¯¥å¢å¼ºæœºå™¨çš„å†…å­˜ä»¥æé«˜æ€§èƒ½ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œmem_fragmentation_ratioçš„æ•°å€¼åœ¨1 ~ 1.5ä¹‹é—´æ˜¯æ¯”è¾ƒå¥åº·çš„ã€‚

### é‡åˆ°å‘½ä»¤

#### DUMP key

Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the RESTORE command.

```sh
redis> SET mykey 10
"OK"
redis> DUMP mykey
"\u0000\xC0\n\t\u0000\xBEm\u0006\x89Z(\u0000\n"
redis> 
```

#### DBSIZE
Available since 1.0.0.

Return the number of keys in the currently-selected database.

```sh
10.111.1.54:6381[2]> dbsize
(integer) 20484594
10.111.1.54:6381[2]> dbsize
(integer) 20455432
```

#### wait numreplicas timeout

Available since 3.0.0.

Time complexity: O(1)

This command blocks the current client until all the previous write commands are successfully transferred and acknowledged by at least the specified number of replicas. If the timeout, specified in milliseconds, is reached, the command returns even if the specified number of replicas were not yet reached.

The command will always return the number of replicas that acknowledged the write commands sent before the WAIT command, both in the case where the specified number of replicas are reached, or when the timeout is reached

Return value
Integer reply: The command returns the number of replicas reached by all the writes performed in the context of the current connection.

```sh
> SET foo bar
OK
> WAIT 1 0
(integer) 1
> WAIT 2 1000
(integer) 1
```

In the following example the first call to WAIT does not use a timeout and asks for the write to reach 1 replica. It returns with success. In the second attempt instead we put a timeout, and ask for the replication of the write to two replicas. Since there is a single replica available, after one second WAIT unblocks and returns 1, the number of replicas reached.

### jedis

```java

public <T> T doInRedis(Function<Jedis, T> fn, Jedis jedis) {
    try {
        return fn.apply(jedis);
    } finally {
        jedis.close();
    }
}

// è°ƒç”¨
public void test(){
    String inRedis = doInRedis(jedis1 -> {
        String result = jedis1.get("key1");
        System.out.println("result = " + result);
        return result;
        }, jedis);
    System.out.println("inRedis = " + inRedis);
}
```

### RESP
Redis clients communicate with the Redis server using a protocol called RESP (REdis Serialization Protocol). While the protocol was designed specifically for Redis, it can be used for other client-server software projects.

RESP is a compromise between the following things:

- Simple to implement.
- Fast to parse.
- Human readable.

The RESP protocol was introduced in Redis 1.2, but it became the standard way for talking with the Redis server in Redis 2.0. This is the protocol you should implement in your Redis client.

RESP is actually a serialization protocol that supports the following data types: Simple Strings, Errors, Integers, Bulk Strings and Arrays.

The way RESP is used in Redis as a request-response protocol is the following:

Clients send commands to a Redis server as a RESP Array of Bulk Strings.
The server replies with one of the RESP types according to the command implementation.
In RESP, the type of some data depends on the first byte:

For Simple Strings the first byte of the reply is "+"
For Errors the first byte of the reply is "-"
For Integers the first byte of the reply is ":"
For Bulk Strings the first byte of the reply is "$"
For Arrays the first byte of the reply is "*"
Additionally RESP is able to represent a Null value using a special variation of Bulk Strings or Array as specified later.

In RESP different parts of the protocol are always terminated with "\r\n" (CRLF).


#### RESP Simple Strings: `"+OK\r\n"`

#### RESP Errors: `"-Error message\r\n"`

#### RESP Integers:  `:0\r\n`  `:1000\r\n`

Integer replies are also extensively used in order to return true or false. For instance commands like EXISTS or SISMEMBER will return 1 for true and 0 for false.
Other commands like SADD, SREM and SETNX will return 1 if the operation was actually performed, 0 otherwise.

#### RESP Bulk Strings

Bulk Strings are used in order to represent a single binary safe string up to 512 MB in length.

Bulk Strings are encoded in the following way:

A "$" byte followed by the number of bytes composing the string (a prefixed length), terminated by CRLF.
The actual string data.
A final CRLF.
So the string "foobar" is encoded as follows:

`"$6\r\nfoobar\r\n"`
When an empty string is just:

`"$0\r\n\r\n"`
RESP Bulk Strings can also be used in order to signal non-existence of a value using a special format that is used to represent a Null value. In this special format the length is -1, and there is no data, so a Null is represented as:

`"$-1\r\n"`

#### RESP Arrays
Clients send commands to the Redis server using RESP Arrays. Similarly certain Redis commands returning collections of elements to the client use RESP Arrays are reply type. An example is the LRANGE command that returns elements of a list.

RESP Arrays are sent using the following format:

A * character as the first byte, followed by the number of elements in the array as a decimal number, followed by CRLF.
An additional RESP type for every element of the Array.


So an empty Array is just the following:

`"*0\r\n"`
While an array of two RESP Bulk Strings "foo" and "bar" is encoded as:

`"*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n"`
As you can see after the *<count>CRLF part prefixing the array, the other data types composing the array are just concatenated one after the other. For example an Array of three integers is encoded as follows:

`"*3\r\n:1\r\n:2\r\n:3\r\n"`
Arrays can contain mixed types, it's not necessary for the elements to be of the same type. For instance, a list of four integers and a bulk string can be encoded as the follows:

```
*5\r\n
:1\r\n
:2\r\n
:3\r\n
:4\r\n
$6\r\n
foobar\r\n
```

#### Sending commands to a Redis Server

- A client sends the Redis server a RESP Array consisting of just Bulk Strings.
- A Redis server replies to clients sending any valid RESP data type as reply.

The client sends the command LLEN mylist in order to get the length of the list stored at key mylist, and the server replies with an Integer reply as in the following example (C: is the client, S: the server).

```
C: *2\r\n
C: $4\r\n
C: LLEN\r\n
C: $6\r\n
C: mylist\r\n

S: :48293\r\n
```

### Pipeline

IMPORTANT NOTE: While the client sends commands using pipelining, the server will be forced to queue the replies, using memory. So if you need to send a lot of commands with pipelining, it is better to send them as batches having a reasonable number, for instance 10k commands, read the replies, and then send another 10k commands again, and so forth. The speed will be nearly the same, but the additional memory used will be at max the amount needed to queue the replies for these 10k commands.

### replication
[åŸæ–‡](https://redis.io/topics/replication)

#### How Redis replication works

Every Redis master has a replication ID: it is a large pseudo random string that marks a given story of the dataset. Each master also takes an offset that increments for every byte of replication stream that it is produced to be sent to replicas, in order to update the state of the replicas with the new changes modifying the dataset. The replication offset is incremented even if no replica is actually connected, so basically every given pair of:

Replication ID, offset
Identifies an exact version of the dataset of a master.

When replicas connect to masters, they use the PSYNC command in order to send their old master replication ID and the offsets they processed so far. This way the master can send just the incremental part needed. However if there is not enough backlog in the master buffers, or if the replica is referring to an history (replication ID) which is no longer known, than a full resynchronization happens: in this case the replica will get a full copy of the dataset, from scratch.

This is how a full synchronization works in more details:

The master starts a background saving process in order to produce an RDB file. At the same time it starts to buffer all new write commands received from the clients. When the background saving is complete, the master transfers the database file to the replica, which saves it on disk, and then loads it into memory. The master will then send all buffered commands to the replica. This is done as a stream of commands and is in the same format of the Redis protocol itself.

You can try it yourself via telnet. Connect to the Redis port while the server is doing some work and issue the SYNC command. You'll see a bulk transfer and then every command received by the master will be re-issued in the telnet session. Actually SYNC is an old protocol no longer used by newer Redis instances, but is still there for backward compatibility: it does not allow partial resynchronizations, so now PSYNC is used instead.

As already said, replicas are able to automatically reconnect when the master-replica link goes down for some reason. If the master receives multiple concurrent replica synchronization requests, it performs a single background save in order to serve all of them.

### redis cluster

[åŸæ–‡](https://redis.io/topics/cluster-tutorial)

So in practical terms, what do you get with Redis Cluster?

- The ability to automatically split your dataset among multiple nodes.
- The ability to continue operations when a subset of the nodes are experiencing failures or are unable to communicate with the rest of the cluster.

The command port and cluster bus port offset is fixed and is always 10000.

Note that for a Redis Cluster to work properly you need, for each node:

- The normal client communication port (usually 6379) used to communicate with clients to be open to all the clients that need to reach the cluster, plus all the other cluster nodes (that use the client port for keys migrations).
- The cluster bus port (the client port + 10000) must be reachable from all the other cluster nodes.

### Redis Cluster configuration parameters

- cluster-enabled <yes/no>: If yes, enables Redis Cluster support in a specific Redis instance. Otherwise the instance starts as a stand alone instance as usual.
- cluster-config-file <filename>: Note that despite the name of this option, this is not a user editable configuration file, but the file where a Redis Cluster node automatically persists the cluster configuration (the state, basically) every time there is a change, in order to be able to re-read it at startup. The file lists things like the other nodes in the cluster, their state, persistent variables, and so forth. Often this file is rewritten and flushed on disk as a result of some message reception.
- cluster-node-timeout <milliseconds>: The maximum amount of time a Redis Cluster node can be unavailable, without it being considered as failing. If a master node is not reachable for more than the specified amount of time, it will be failed over by its slaves. This parameter controls other important things in Redis Cluster. Notably, every node that can't reach the majority of master nodes for the specified amount of time, will stop accepting queries.
- cluster-slave-validity-factor <factor>: If set to zero, a slave will always try to failover a master, regardless of the amount of time the link between the master and the slave remained disconnected. If the value is positive, a maximum disconnection time is calculated as the node timeout value multiplied by the factor provided with this option, and if the node is a slave, it will not try to start a failover if the master link was disconnected for more than the specified amount of time. For example if the node timeout is set to 5 seconds, and the validity factor is set to 10, a slave disconnected from the master for more than 50 seconds will not try to failover its master. Note that any value different than zero may result in Redis Cluster to be unavailable after a master failure if there is no slave able to failover it. In that case the cluster will return back available only when the original master rejoins the cluster.
- cluster-migration-barrier <count>: Minimum number of slaves a master will remain connected with, for another slave to migrate to a master which is no longer covered by any slave. See the appropriate section about replica migration in this tutorial for more information.
- cluster-require-full-coverage <yes/no>: If this is set to yes, as it is by default, the cluster stops accepting writes if some percentage of the key space is not covered by any node. If the option is set to no, the cluster will still serve queries even if only requests about a subset of keys can be processed.
- cluster-allow-reads-when-down <yes/no>: If this is set to no, as it is by default, a node in a Redis Cluster will stop serving all traffic when the cluster is marked as fail, either when a node can't reach a quorum of masters or full coverage is not met. This prevents reading potentially inconsistent data from a node that is unaware of changes in the cluster. This option can be set to yes to allow reads from a node during the fail state, which is useful for applications that want to prioritize read availability but still want to prevent inconsistent writes. It can also be used for when using Redis Cluster with only one or two shards, as it allows the nodes to continue serving writes when a master fails but automatic failover is impossible.

### resharding 

To start a resharding just type:

redis-cli --cluster reshard 127.0.0.1:7000
You only need to specify a single node, redis-cli will find the other nodes automatically.

Currently redis-cli is only able to reshard with the administrator support, you can't just say move 5% of slots from this node to the other one (but this is pretty trivial to implement). So it starts with questions. The first is how much a big resharding do you want to do:

How many slots do you want to move (from 1 to 16384)?
We can try to reshard 1000 hash slots, that should already contain a non trivial amount of keys if the example is still running without the sleep call.

Then redis-cli needs to know what is the target of the resharding, that is, the node that will receive the hash slots. I'll use the first master node, that is, 127.0.0.1:7000, but I need to specify the Node ID of the instance. This was already printed in a list by redis-cli, but I can always find the ID of a node with the following command if I need:

$ redis-cli -p 7000 cluster nodes | grep myself
97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460
Ok so my target node is 97a3a64667477371c4479320d683e4c8db5858b1.

Now you'll get asked from what nodes you want to take those keys. I'll just type all in order to take a bit of hash slots from all the other master nodes.

After the final confirmation you'll see a message for every slot that redis-cli is going to move from a node to another, and a dot will be printed for every actual key moved from one side to the other.

While the resharding is in progress you should be able to see your example program running unaffected. You can stop and restart it multiple times during the resharding if you want.

At the end of the resharding, you can test the health of the cluster with the following command:

redis-cli --cluster check 127.0.0.1:7000
All the slots will be covered as usual, but this time the master at 127.0.0.1:7000 will have more hash slots, something around 6461.


### CLUSTER REPLICATE node-id
Available since 3.0.0.

Time complexity: O(1)

The command reconfigures a node as a replica of the specified master. If the node receiving the command is an empty master, as a side effect of the command, the node role is changed from master to replica.

Once a node is turned into the replica of another master node, there is no need to inform the other cluster nodes about the change: heartbeat packets exchanged between nodes will propagate the new configuration automatically.

A replica will always accept the command, assuming that:

The specified node ID exists in its nodes table.
The specified node ID does not identify the instance we are sending the command to.
The specified node ID is a master.

### é…ç½®æ–‡ä»¶

appendonly yes                  #åœ¨/data/redis/ç›®å½•ç”Ÿæˆappendonly.aofæ–‡ä»¶ï¼Œå°†æ¯ä¸€æ¬¡å†™æ“ä½œè¯·æ±‚éƒ½è¿½åŠ åˆ°appendonly.aof æ–‡ä»¶ä¸­

### æ¢å¤

1. psync åŒæ­¥rdb å’Œaof æ–‡ä»¶ï¼Œä¸€ç›´åŒæ­¥aof ç›´åˆ°å–æ¶ˆ
2. å…ˆä»rdb æ¢å¤æ•°æ®
3. è¯»å–aofï¼Œæ¢å¤

### No reachable node in cluster

é›†ç¾¤æ¨¡å¼è¦æ‰“å¼€

```sh
âœ  ~ redis-cli -c -p 7001
127.0.0.1:7001> cluster info
cluster_state:fail
cluster_slots_assigned:0
cluster_slots_ok:0
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:1
cluster_size:0
cluster_current_epoch:0
cluster_my_epoch:0
cluster_stats_messages_sent:0
cluster_stats_messages_received:0
127.0.0.1:7001> exit

âœ  create-cluster ./create-cluster create
>>> Performing hash slots allocation on 6 nodes...
Master[0] -> Slots 0 - 5460
Master[1] -> Slots 5461 - 10922
Master[2] -> Slots 10923 - 16383
Adding replica 127.0.0.1:7005 to 127.0.0.1:7001
Adding replica 127.0.0.1:7006 to 127.0.0.1:7002
Adding replica 127.0.0.1:7004 to 127.0.0.1:7003
>>> Trying to optimize slaves allocation for anti-affinity
[WARNING] Some slaves are in the same host as their master
M: 6ebf203431654080c971d1d2056e1bfc3823b073 127.0.0.1:7001
   slots:[0-5460] (5461 slots) master
M: 5c50d86191663883ec10e25bcc488e49ebed4b7e 127.0.0.1:7002
   slots:[5461-10922] (5462 slots) master
M: 18669db5e03ddeccc5b739793b64816d52124d75 127.0.0.1:7003
   slots:[10923-16383] (5461 slots) master
S: ecfa79d2b273fd27fbfe1c89244ae6926372a2c5 127.0.0.1:7004
   replicates 18669db5e03ddeccc5b739793b64816d52124d75
S: e7fca47ed70cdff066dd98f16c4046f32346c042 127.0.0.1:7005
   replicates 6ebf203431654080c971d1d2056e1bfc3823b073
S: ca9dabc53c565e15ab7e0475b5cb2c0839d21210 127.0.0.1:7006
   replicates 5c50d86191663883ec10e25bcc488e49ebed4b7e
Can I set the above configuration? (type 'yes' to accept): yes
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join
.
>>> Performing Cluster Check (using node 127.0.0.1:7001)
M: 6ebf203431654080c971d1d2056e1bfc3823b073 127.0.0.1:7001
   slots:[0-5460] (5461 slots) master
   1 additional replica(s)
S: ca9dabc53c565e15ab7e0475b5cb2c0839d21210 127.0.0.1:7006
   slots: (0 slots) slave
   replicates 5c50d86191663883ec10e25bcc488e49ebed4b7e
S: ecfa79d2b273fd27fbfe1c89244ae6926372a2c5 127.0.0.1:7004
   slots: (0 slots) slave
   replicates 18669db5e03ddeccc5b739793b64816d52124d75
S: e7fca47ed70cdff066dd98f16c4046f32346c042 127.0.0.1:7005
   slots: (0 slots) slave
   replicates 6ebf203431654080c971d1d2056e1bfc3823b073
M: 5c50d86191663883ec10e25bcc488e49ebed4b7e 127.0.0.1:7002
   slots:[5461-10922] (5462 slots) master
   1 additional replica(s)
M: 18669db5e03ddeccc5b739793b64816d52124d75 127.0.0.1:7003
   slots:[10923-16383] (5461 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.



âœ  ~ redis-cli -c -p 7001
127.0.0.1:7001> cluster info
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:40
cluster_stats_messages_pong_sent:42
cluster_stats_messages_sent:82
cluster_stats_messages_ping_received:37
cluster_stats_messages_pong_received:40
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:82
127.0.0.1:7001> exit
```

### pub/sub

```sh
âœ  docker_images redis-cli
127.0.0.1:6379> SUBSCRIBE d
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "d"
3) (integer) 1
1) "message"
2) "d"
3) "abcdefg"

127.0.0.1:6379> PUBLISH d abcdefg
(integer) 1


âœ  docker_images redis-cli
127.0.0.1:6379> SUBSCRIBE d e
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "d"
3) (integer) 1
1) "subscribe"
2) "e"
3) (integer) 2
1) "message"
2) "d"
3) "abcdefg"
1) "message"
2) "e"
3) "gfedcba"

127.0.0.1:6379> PUBLISH d abcdefg
(integer) 1
127.0.0.1:6379> PUBLISH e gfedcba
(integer) 1

```

####  subscribe

SUBSCRIBE channel [channel ...]
Available since 2.0.0.

Time complexity: O(N) where N is the number of channels to subscribe to.

Subscribes the client to the specified channels.

Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional SUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE, PUNSUBSCRIBE, PING, RESET and QUIT commands.

#### psubscribe

PSUBSCRIBE pattern [pattern ...]
Available since 2.0.0.

Time complexity: O(N) where N is the number of patterns the client is already subscribed to.

Subscribes the client to the given patterns.

Supported glob-style patterns:

h?llo subscribes to hello, hallo and hxllo
h*llo subscribes to hllo and heeeello
h[ae]llo subscribes to hello and hallo, but not hillo
Use \ to escape special characters if you want to match them verbatim.

#### PUNSUBSCRIBE

PUNSUBSCRIBE [pattern [pattern ...]]
Available since 2.0.0.

Time complexity: O(N+M) where N is the number of patterns the client is already subscribed and M is the number of total patterns subscribed in the system (by any client).

Unsubscribes the client from the given patterns, or from all of them if none is given.

When no patterns are specified, the client is unsubscribed from all the previously subscribed patterns. In this case, a message for every unsubscribed pattern will be sent to the client.

#### message format 
Format of pushed messages
A message is a Array reply with three elements.

The first element is the kind of message:

subscribe: means that we successfully subscribed to the channel given as the second element in the reply. The third argument represents the number of channels we are currently subscribed to.

unsubscribe: means that we successfully unsubscribed from the channel given as second element in the reply. The third argument represents the number of channels we are currently subscribed to. When the last argument is zero, we are no longer subscribed to any channel, and the client can issue any kind of Redis command as we are outside the Pub/Sub state.

message: it is a message received as result of a PUBLISH command issued by another client. The second element is the name of the originating channel, and the third argument is the actual message payload.

#### timing of expired events

Timing of expired events
Keys with a time to live associated are expired by Redis in two ways:

When the key is accessed by a command and is found to be expired.
Via a background system that looks for expired keys in the background, incrementally, in order to be able to also collect keys that are never accessed.
The expired events are generated when a key is accessed and is found to be expired by one of the above systems, as a result there are no guarantees that the Redis server will be able to generate the expired event at the time the key time to live reaches the value of zero.

If no command targets the key constantly, and there are many keys with a TTL associated, there can be a significant delay between the time the key time to live drops to zero, and the time the expired event is generated.

Basically expired events are generated when the Redis server deletes the key and not when the time to live theoretically reaches the value of zero.

#### config

127.0.0.1:6379> config set notify-keyspace-events KExg
OK
127.0.0.1:6379> config get *ev*
1) "lazyfree-lazy-eviction"
2) "no"
3) "loglevel"
4) "notice"
5) "notify-keyspace-events"
6) "KE"


### --bigkeys

bigkeyså¯¹é—®é¢˜çš„æ’æŸ¥éå¸¸æ–¹ä¾¿ï¼Œä½†æ˜¯åœ¨ä½¿ç”¨å®ƒæ—¶å€™ä¹Ÿæœ‰å‡ ç‚¹éœ€è¦æ³¨æ„:

å»ºè®®åœ¨ä»èŠ‚ç‚¹æ‰§è¡Œï¼Œå› ä¸º--bigkeysä¹Ÿæ˜¯é€šè¿‡scanå®Œæˆçš„ã€‚
å»ºè®®åœ¨èŠ‚ç‚¹æœ¬æœºæ‰§è¡Œï¼Œè¿™æ ·å¯ä»¥å‡å°‘ç½‘ç»œå¼€é”€ã€‚
å¦‚æœæ²¡æœ‰ä»èŠ‚ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨--iå‚æ•°ï¼Œä¾‹å¦‚(--i 0.1 ä»£è¡¨100æ¯«ç§’æ‰§è¡Œä¸€æ¬¡)
--bigkeysåªèƒ½è®¡ç®—æ¯ç§æ•°æ®ç»“æ„çš„top1ï¼Œå¦‚æœæœ‰äº›æ•°æ®ç»“æ„éå¸¸å¤šçš„bigkeyï¼Œä¹Ÿæä¸å®šï¼Œæ¯•ç«Ÿä¸æ˜¯è‡ªå·±å†™çš„ä¸œè¥¿å˜›

### æ¸…ç†redisç©ºé—´
[åŸæ–‡](https://zhuanlan.zhihu.com/p/259719544)

