---
title: 第二章 面向对象技术
excerpt: |
  第二章 面向对象技术
category: 设计模式
feature_image: "https://picsum.photos/2560/600?image=872"
---
## 第2章 面向对象技术 ##

###  什么是面向对象

什么是面向对象？很多初学者都会问这个问题，软件工程学家Coad和YourDon曾经给出一个简单的定义：

`	OO = Objects + Classes + Inheritance + Communication with Messages`

也就是说，面向对象就是既使用对象又使用类和继承等机制，而且对象之间仅能通过传递消息实现彼此通信。面向对象方法以对象为中心，它有以下几个基本特点：

1. 认为客观世界是由各种对象组成的，任何事物都是对象，复杂的对象可以由比较简单的对象以某种方式组合而成。
2. 具有相同数据和操作的对象可以归纳为类。对象是类的一个实例。对象的数据也称为对象的属性，对象的操作也称为对象的方法。对象的属性与方法成为一个实体，对外屏蔽内部细节（称作封装）。
3. 类可以派生子类，子类除了继承父类的全部特征外，还可以有自己的特征。
4. 对象之间通过消息进行通信以实现对象之间的动态联系，通过关联表达对象之间的静态联系。**对象与传统的数据有本质区别，它不是被动地等待外界对它施加操作，相反它是进行处理的主题，必须发消息请求它执行某个操作，处理它的私有数据，而不能直接从外界对私有数据进行操作，这就是封装性。**这种灵活的消息传递方式，便于体现并行和分布式结构。

### 面向对象的基本概念

#### 对象

**对象是对问题域中某个实体的抽象，设立某个对象就反映了软件系统保存有关它的信息并且与它进行交互的能力。**

**面向对象方法学中的对象是由描述该对象属性的数据以及可以对这些数据施加的所有操作封装在一起构成的统一体。**对象可以进行的操作表示它的动态行为。通常把对象的操作称为服务或方法。

从不同角度可以给出对象的不同定义，目前比较常用的定义是：**对象是封装了数据结构及可以施加在这些数据结构上的操作的封装体，这个封装体有可以唯一地标识它的名字，而且向外界提供一组服务（即公有的操作）。**一个对象可以有多个属性和多项服务。

**对象具有以下一些基本特点：以数据为中心；对象是主动的；实现了数据封装；本质上具有并行性；模块独立性好。**

#### 类

**人类习惯于把有相似特征的事物归为一类，分类是人类认识客观世界的基本方法。在面向对象的软件技术中，把具有相同数据和相同操作的一级相似对象也归为一“类”。“类”就是对具有相同数据和相同操作的一组相似对象的定义。类是对具有相同属性和行为的一个或多个对象的描述。**

**由某个特定的类所描述的一个具体的对象被称为实例。**实际上，类是建立对象时使用的“样板”，按照这个样板所建立的一个个具体的对象，就是类的实际例子，通常称为实例。**类是对具有相同属性和行为的一组相似的对象的抽象，类在现实世界中并不能真正存在。**

**类反映对象的共同性定义，而对象则是满足该定义的一个具体的实例化的个体。**

#### 封装

在面向对象的程序中，把数据和实现操作的代码集中起来放在对象内部。对外部，表示对象状态的数据和实现操作的代码与局部数据都不可见，更不能从外面直接访问或修改这些数据和代码。**数据的表示方式和对数据的操作细节被隐藏起来，用户通过操作接口对数据进行操作，这就是数据的封装。**封装体现了“信息隐藏和局部化”原则，使用一个对象的时候，只需知道它向外界提供的接口形式，无须知道它的数据结构细节和实现操作的算法。

对象的封装性具有如下特点：

1. 有一个清晰的边界。所有私有数据和实现操作的代码都被封装在这个边界内，从外面看不见，更不能直接访问。
2. 有确定的接口（即协议）。这些接口就是对象可以接收的消息，只能通过向对象发送消息来使用它。
3. 受保护的内部实现。实现对象功能的细节（私有数据和代码）不能在定义该对象的类的范围外访问。

#### 继承

**广义地说，继承是指能够直接获得已有的性质和特征，而不必重复定义它们。**在面向对象的软件技术中，**继承是子类自动地共享父类中定义的属性和方法的机制。在定义子类时，不必重复定义那些已在父类中定义的属性和方法，只要声明自己是某个父类的子类，把精力集中于定义本子类所特有的属性和方法上即可。**

继承具有传递性。属于某个类的对象除了具有该类所描述的性质外，还具有类等级中该类上层全部基类描述的一切性质。

通常一个子类只有一个父类时，也就是说，当类等级为树形结构时，类的继承是单继承；在有些情况下，一个类可能需要同时有两个以上的父类时，类的继承是多重继承。**多重继承的类可以组合多个父类的性质构成所需要的性质。**

**继承性使得相似的对象可以共享程序代码和数据结构，从而大大减少了程序中的冗余信息。派生出新的子类的办法，使得对软件的修改变得更加容易。继承性使得用户在开发新的应用系统时不必完全从零开始，可以继承原有的相似系统的功能或从类库中 选取需要的类，再派生出新的类以实现所需要的功能。继承提高了软件的可复用性。**

#### 消息

现实世界是由许多不同的对象组成的，它们之间必然有各种联系和交互。**对象之间的联系称为对象的交互。一个对象向另一个对象发出的请求被称为消息。**消息是要求某个对象执行在定义它的那个类中所定义的某个操作的朝夕相处说明。一个消息由下述三个部分组成：**接收消息的对象，消息选择符（也称为消息名），零个或多个变元。**

**方法也是类的外部接口的另一种说法，实际就是类对象的某一个操作，要使类对象进行某一种操作，先要给以消息，也可以方法与消息等同。因此，消息是要求对象进行动作的说明或命令或指导，是对象之间相互请求或相互协作的途径。**

把发送消息的对象称为发送者，接收消息的对象称为接收者。对象间的联系，只能通过传递消息来进行。**对象也只有在收到消息后才能选用方法而被激活。**

消息具有三个性质：

1. 同一个对象可以接收不同形式的多个消息，做出不同的响应。
2. 相同形式的消息可以传递给不同的对象，所做出的响应可以是不同的。
3. 消息的发送可以不考虑具体的接收者，对象可以响应消息，也可以不响应。

对于一个并发系统对象之间的消息传递要复杂很多。在并发系统中，多个控制线程并发执行。消息是控制线程之间传送的通信信息，消息的用途可以是向接收者发出一个服务请求、提交一些数据、发布一个事件信息、传递一个同步控制信息等。

#### 结构与连接

仅仅用一些对象描述问题域中的事物是不够的。因为在任何一个较为复杂的问题域中，事物之间并不是相互孤立、各不相关的，而是具有一定的关系，并因此构成一个有机的整体，从而使对象之间的交互与合作构成更高级的行为。**对象之间常见的联系有分类关系（一般与特殊的关系）、组成关系（部分与整体的关系）、对象之间的静态联系和对象之间的动态联系。**在OO方法中通常采用结构与连接来表现这些联系，即一般-特殊结构、整体-部分结构、实例连接和消息连接描述对象之间的四种关系。

#### 多态性

**多态性是指在基类中定义的属性或服务被子类继承后，可以具有不同的数据类型或表现出不同的行为。**这使得同一个属性或服务名在基类及子类中可具有不同的语义。

**不同层次中的每个类可共享属性名（服务），但却各自按自己的需要有不同的实现。**当对象接收到发送给它的消息时，根据该对象所属于的类动态选用在该类中定义的实现算法。

**多态性机制不但为面向对象软件系统提供了灵活性，减少冗余信息，而且显著提高了软件的可重用性和可扩充性。**

**派生类继承基类的属性或服务操作的名称，而根据派生对象的特性修改属性的数据类型或服务操作的内容，称为重载（Overloading）。重载是实现多态性的方法之一。**

### 面向对象的分析

面向对象的分析（Object-Oriented Analysis，OOA）的主要任务是分析问题论域，找出问题解决方案，发现对象、分析对象的内部构成和外部关系，建立软件系统的对象模型。

**面向对象的分析过程并不从考虑对象开始，而是从理解系统的使用方式开始**：如果系统是人机交互的，则考虑被人使用的方式；如果是设计过程控制的，则考虑被机器使用的方式；如果是系统协调和控制应用，则考虑被其他程序使用的方式。**定义了使用场景后，就开始软件的建模过程**。

**分析工作主要包括三项内容：理解、表达和验证。需求分析过程是系统分析员与用户及领域专家反复交流和多次修正的过程。**也就是说，理解和验证的过程通常交替进行，反复迭代，而且往往需要利用原型系统作为辅助工具。

**面向对象的分析的关键，是识别出问题域内的对象，并分析它们相互间的关系，最终建立起问题域的简洁、精确、可理解的正确模型。**在用面向对象观点建立起的三种模型（对象模型、动态模型、功能模型）中，对象模型是最基本、最重要、最核心的。

**面向对象的分析，就是抽取和整理用户需求并建立问题域精确模型的过程。通常，面向对象分析过程从分析陈述用户需求的文件开始。但是，不应该认为需求陈述是一成不变的，而应该把它作为细化和完善实际需求的基础。接下来，系统分析员应该深入理解用户需求，抽象出目标系统的本质属性，并用模型准确地表示出来。**

面向对象的分析的基本步骤如下：

1. 问题域分析

   分析应用领域的业务范围、业务规则和业务处理过程，确定系统的责任、范围和边界，确定系统的需求。在分析中需要着重对系统与外部的用户和其他系统的交互进行分析，确定交互的内容、步骤和顺序。

2. 发现和定义对象与类

   **识别对象和类，确定它们的内部特征——属性和服务操作，是从现实世界到概念模型的抽象过程。**抽象是面向对象的分析的基本原则。系统分析员不必了解问题域中的一切方面，只需**研究与系统目标有关的事物及其基本特征，并舍弃个体事物的细节差异，抽取其共同的特征而获得有关事物的概念，从而发现对象和类。定义对象是OOA诸多方法中共同的一点。**定义对象的主要活动包括五个层次：确定对象、确定属性、定义服务、建立结构和确定关联。

3. 识别对象的外部联系

   在发现和定义对象与类的过程中，需要同时识别对象与对象、类与类之间的各种外部联系，包括结构性的静态联系和行为性的动态联系，包括一般与特殊、整体与部分、实例连接、消息连接等联系。

4. 建立系统的静态结构模型

  分析系统的静态结构，建立系统的静态结构模型，并且把它们用图形和文字说明表达出来。在前面对于类和对象及其联系的分析基础上，绘制类图和对象图、系统与子系统结构图等，编制相应的说明文档。

5. 建立系统的动态行为模型

  分析系统的行为，建立系统的动态行为模型，并且把它们用图形和文字说明表达出来。如Use Case图、交互图、活动图、状态图等，编制相应的说明文档。

  **面向对象的分析对系统行为的分析以对象为单位，包括对象的服务操作、对象之间的交互、消息传递、对象的转换等。**

  **系统的静态结构模型与动态模型，以及系统需求说明书、系统分析说明书构成系统的分析模型。它是系统分析活动的成果，是下一步进行系统设计的基础。**

### 面向对象的设计

如前所述，**分析是提取和整理用户需求，并建立问题域模型的过程，而设计则是把分析阶段的需求转变成符合成本和质量要求的、抽象的系统实现方案过程。**从面向对象的分析到面向对象的设计（通常缩写为OOD），是一个逐渐扩充模型的过程。**面向对象的设计再细分为系统设计和对象设计。**系统设计确定实现系统的策略和目标系统的高层结构。对象设计的目的是确定解空间中的类、关联、接口形式及实现服务的算法。

#### 面向对象的设计准则

为了使得设计是一个优秀设计，在进行面向对象的设计时，应该注意以下准则：

1. 模块化

   模块的基本元素是对象。它是把数据结构和操作数据的方法紧密地结合在一起所构成的模块。

2. 抽象

   类实际上是一种抽象数据类型，它包括规格说明抽象和参数化抽象。其中，对外开放的公共接口构成了类的规格说明，这种接口规定了外界可以使用的合法操作符，利用这些操作符可以对类实例中包含的数据进行操作。**所谓参数化抽象，是指在描述类的规格说明时，并不具体指定所要操作的数据类型，而是把数据类型作为参数。**

3. 信息隐藏

   信息隐藏通过对象的封装性实现。类结构分离了接口与实现，从而支持了信息隐藏。对于使用类的用户来说，属性的表示方法和操作的实现算法都应该是隐藏的。

4. 弱耦合

   **在面向对象方法中，耦合主要指不同对象之间相互关联的紧密程序**。当两个对象必须相互联系相互依赖时，应该通过类的公共接口实现耦合，而不应该依赖类的具体实现细节。一般来说，**对象之间的耦合可分两类：交互耦合和继承耦合。**其中，**对象之间的耦合通过消息连接来实现交互耦合**，交互耦合应该尽可能松散，应遵守以下两个准则：

   1. 尽量降低消息连接的复杂程度。应该尽量减少消息中包含的参数个数，降低参数的复杂程度。
   2. 减少对象发送（或接收）的消息数。

   **一般化类与特殊类之间的耦合称为继承耦合，**继承耦合应该尽可能紧密。从本质上看，通过继承关系结合起来的基类和派生类，构成了系统中粒度更大的模块。因此，它们彼此间应该结合得越紧密越好。

5. 强内聚

   **内聚衡量模块内各元素彼此结合的紧密程度。**在面向对象的设计中包括如下3种内聚：

   1. 服务内聚：一个服务应该完成一个且仅完成一个功能。
   2. 类内聚：一个类应该只有一个用途，它的属性和服务应该是高内聚的。
   3. 一般-特殊内聚：一般-特殊结构应该正确地抽取相应的领域知识。也就是说，要符合多数人的概念。

6. 可重用

   重用是指同一事物不做修改或稍加改动就多次重复使用。软件重用是指尽量使用已有类，包括开发环境提供的类库，以及以往开发类似系统时创建的类；如果确实需要创建新类，则在设计这些新类的协议时，应该考虑将来的可重用性。软件成分的重用级别包括代码重用（代码剪贴、源代码包含（include）和继承）、设计结果重用和分析结果重用。面向对象技术中的“类”，是比较理想的可重用软构件，可称为类构件。类构件的重用方式有实例重用、继承重用和多态重用三种：

   1. 实例重用。可以使用适当的构造函数，按照需要创建类的实例，然后向所创建的实例发送适当的消息，启动相应的服务，完成需要完成的工作；可以用几个简单的对象作为类的成员，创建出一个更复杂的类。
   2. 继承重用。为提高继承重用的效果，关键是设计一个合理的、具有一定深度的类构件继承层次结构。这样做有下述三个好处：每个子类在继承父类的属性和服务的基础上，只加入少量新属性和新服务；降低了每个类构件的接口复杂度，表现出一个清晰的进化过程，提高了每个子类的可理解性，为软件开发人员提供了更多可重用的类构件；为多态重用奠定了良好的基础。
   3. 多态重用。使对象的对外接口更加一般化，从而降低了消息连接的复杂程度，提供一种简便可靠的软构件组合机制。设计类时，应注意以下可能影响重用性的操作：与表示方法有关的操作，如不同实例的比较、显示、擦除等；与数据结构、数据大小等有关的操作；与外部设备有关的操作，如设备控制；实现算法在将来可能会改进（或改变）的核心操作。

   **为了帮助软件开发人员提高面向对象的设计的质量，人们积累了一些经验，主要包括以下几条启发规则：**

   1. 设计结果应该清晰易懂用词一致，使用已有的协议，减少消息模式的数目，避免模糊的定义。
   2. 一般-特殊结构的深度应适当。应该使类等级中包含的层次数适当。一般来说，在一个中等规模（大约包含100个类）的系统中，类等级层次数应保持为7 +- 2。**不应该仅仅从方便编码的角度出发随意创建派生类。**应该使一般-特殊结构与领域知识或常识保持一致。
   3. 设计简单的类。避免包含过多的属性，有明确的定义，尽量简化对象之间的合作关系，不要提供太多服务。
   4. 使用简单的协议。一般来说，消息中的参数不要超过3个。经验表明，通过复杂消息相互关联的对象是紧耦合的，对一个对象的修改往往导致其他对象的修改。
   5. 使用简单的服务。一般来说，应该尽量避免使用复杂的服务。如果一个服务中包含了过多的源程序语句，或者语句嵌套层次太多，或者使用了复杂的CASE语句，则应该仔细检查这个服务，设法分解或简化它。如果需要在服务中使用CASE语句，通常应该考虑用一般-特殊结构代替这个类的可能性。
   6. 把设计变动减至最小。通常，设计的质量越高，设计结果保持不变的时间也越长。即使出现必须修改设计的情况，也应该使修改的范围尽可能小。

#### 面向对象的设计过程

面向对象的设计在系统分析的成果上进行，着重研究系统的软件实现问题，构建设计模型。面向对象的设计模型分为问题域子系统、人-机交互子系统、任务管理子系统和数据管理子系统，面向对象的设计过程如下。

1. 设计对象和类

   在OOA的对象模型的基础上，具体设计对象与类的属性、服务操作，设计对象与类的各种外部联系的实现结构，设计消息与事件的内容、格式等。类与对象的设计应充分利用预定义的系统类库或其他来源的现有的类，把它们融入到解决方案中，并采用继承、复用、演化等方法设计所需要的新类。

2. 设计系统结构

   一个复杂的软件系统由若干个子系统组成，一个子系统由若干软件组件组成。**设计系统的主要任务是设计组件与子系统，以及它们间相互的静态和动态关系。**

   通常，软件系统结构的组织方式有两种：层次结构和块状结构。

   1. 层次结构

      这种组织方案把软件系统组织成一个层次系统，每层是一个子系统。

   2. 块状结构

      这种组织方案把软件系统垂直地分解成若干相对独立的、弱耦合的子系统，一个子系统相当于一块，每块提供一种类型的服务。

3. 设计问题域子系统

   仅需从实现角度对问题域模型做一些补充或修改，主要是增添、合并或分解对象类、属性及服务，调整继承关系，等等。

4. 设计人-机交互子系统

   在面向对象分析过程中，已经对用户界面需求进行了初步分析。在面向对象设计过程中，则应该对系统的人-机交互子系统进行详细设计，以确定人-机交互的细节。设计人-机交互子系统的准则是一致性、减少步骤、及时提供反馈信息、提供撤销命令、无须记忆、易学、富有吸引力。

   设计人-机交互子系统的策略是分类用户、描述用户、设计命令层次、设计人-机交互类。

5. 设计任务管理子系统

   设计工作的一项重要内容就是，确定哪些是必须同时动作的对象，哪些是相互排斥的对象，然后进一步设计任务管理子系统。设计工作主要包括分析并发性和设计任务管理。

6. 设计数据管理子系统

   数据管理子系统负责数据的管理，包括数据的录入、操纵、检索、存储，以及对永久性数据的访问等。设计数据管理子系统的主要任务是确定数据管理的方法，设计数据库与数据文件的逻辑结构和物理结构，设计实现数据管理的对象类。

7. 设计优化

   系统设计的结果需要优化，尽可能地提高系统的性能和质量。但是一个系统的质量和性能有多个，如运行速度、内存开销、资源占用、模型清晰度等，它们的重要性是不同的，有些指标之间还存在矛盾。例如，要求运行速度常导致多用内存，多占资源。因此，应根据实际情况制定一个设计优化的折中方案，进行系统的优化，提高系统的性能和质量。可以通过增加冗余关联提高访问效率、调整查询次序、保留派生属性的方法来提高效率，同时适当调整继承关系来优化设计。

### 面向对象方法比较

**面向对象的方法都支持3种基本的活动：识别对象和类，描述对象和类之间的关系，以及通过描述每个类的功能定义对象的行为。**

**为了发现对象和类，开发人员要在系统需求和系统分析的文档中查找名词和名词短语，包括可感知的事物（汽车、压力、传感器）、角色（母亲、教师、政治家）、事件（中断、请求）、互相作用（借贷、开会、交叉）、人员、场所、组织、设备和地点。**通过浏览使用系统的脚本发现重要的对象和其责任，是面向对象分析和设计过程初期的重要的技术。

**当发现重要的对象后，通过一组互相关联的模型详细表示类之间的关系和对象的行为。**这些模型从静态逻辑、动态逻辑、静态物理和动态物理四个不同的侧面表示了软件的体系结构。

**静态逻辑模型描述实例化（类成员关系）、关联、聚焦（整体/部分）和一般化（继承）等关系，这被称为对象模型。**一般化关系表示属性和方法的继承关系。定义对象模型的图形符号体系通常是从用于数据建模的实体关系图导出的。对设计十分重要的 约束，如基数（一对一、一对多、多对多），也在对象模型中表示。

**动态逻辑模型描述对象之间的交互。交互就是通过一组协同对象以及对象之间消息，来定义系统运行时的行为。**

静态物理模型通过模块描述代码的布局。动态物理模型描述软件的进程和线程体系结构。

#### Booch面向对象方法

Booch强调反复的处理和开发人员的创造性，在设计过程中不存在严格的条条框框和次序，认为软件开发是一个螺旋上升的过程。在这个螺旋上升的每个周期中，都遵循下列步骤：**在给定的抽象层次上识别类和对象，识别这些对象和类的主义，识别这些类和对象之间的关系，实现类和对象，以及说明每一个界面。**

1. Booch基本思想

   Booch在其OOAda中提出了面向对象开发的4个模型：逻辑模型、物理模型及其相应的静态和动态语义。对逻辑结构的静态模型，OOAda提供对象图和类图；对逻辑结构的动态模型，OOAda提供了状态迁移图和交互图；对于物理结构的静态模型，OOAda提供了模块图和进程图。

   在Booch方法中，用于说明系统要求的表示方法和符号体系非常丰富，相当浸洗，主要包括以下几个部分。

   - 类图
   - 对象图
   - 状态迁移图
   - 时序图
   - 模块图
   - 进程图

   用于类和对象建模的符号体系使用注释和不同的图符（如不同的箭头）表达详细的信息。Booch建议在设计的初期可以用符号体系的一个子集，随后不断添加细节。对每一个符号体系还有一个文本的形式，由每一个主要结构的描述模板组成。符号体系由大量的图符定义，但是其语法和语义并没有严格的定义。

2. Booch方法的过程

   Booch方法的过程是迭代进行的，每次迭代的过程包括以下五个步骤：

   1. 在给定的抽象层次上识别类和对象

      **类和对象的识别包括找出问题空间中关键的抽象和产生动态行为的重要机制。开发人员可以通过研究问题域的术语发现关键的抽象。**

   2. 识别这些对象和类的语义

      语义的识别主要是建立前一阶段识别出的类和对象的含义。开发人员确定类的行为（即方法）和类及对象之间的互相作用（即行为的规范描述）。该阶段利用状态迁移图描述对象的状态的模型，利用时态图（系统中的时态约束）和对象图（对象之间的互相作用）描述行为模型。

   3. 识别这些类和对象之间的关系

      在关系识别阶段描述静态和动态的关系模型。这些关系包括使用、实例化、继承、关联和聚焦等。类和对象之间的可见性也在此时确定。

   4. 实现类和对象

      在类和对象的实现阶段要考虑如何用选定的编程语言实现，如何将类和对象组织成模块。

   5. 说明每一类的界面和实现

      这一步的主要任务是将类和对象分配到不同的模块中，而且将可以同时执行的进程分配到不同的处理机上。这一步是对过程的进一步细化和完善，往往有助于发现新的类和对象。从而影响下一周期的开发工作。

   上述活动不仅仅是一个简单的步骤序列，而是对系统的逻辑和物理视图不断细化的迭代和渐增的开发过程。在面向对象的设计方法中，Booch强调基于类和对象的系统逻辑视图与基于模块和进程的系统物理视图之间的区别。他还区别了系统的静态和动态模型。然而，他的方法偏向于系统的静态描述，对动态描述支持较少。

3. Booch方法的特点

   1. 独立于任何语言的、开放式的实现过程。可以使开发人员很快地从任意开发阶段重新回到起始的分析阶段。
   2. 给开发者提供了丰富的图技术，可以从许多不同的视点来看待开发的模型。这种方法给出了能够表达模型的不同方面的丰富的观点，提供了项目或组织自己开发的灵活性。
   3. 把逻辑和物理观点分离出来。逻辑观点包括类和对象结构，这些图表构成了基本符号，它是系统的静态描述。除了静态图外，还有状态转换图和时序图表示系统的动态行为。
   4. 无论小系统还是复杂问题，开发代价都是成比例地增长或降低，对开发复杂系统非常有用。
   5. 该方法强调反复的处理和开发人员的创造性，也就是怎样找到每个对象和类的操作技术以及怎样进行建模都取决于开发人员，并没有发展成为一个完整过程。这也是该方法的最大不足。

#### Jacobson方法

Jacobson于1994年提出了面向对象的软件工程（OOSE）方法，该方法最大特点是面向用例（Use Case）。

#### Coad-Yourdon面向对象方法

OOAD（Object-Oriented Analysis and Design）方法是由Peter Coad和Edward Yourdon在1991年提出的。这是一种逐步进阶的面向对象建模方法。Coad-Yourdon方法严格区分了面向对象分析OOA和面向对象设计OOD。

从Coad-Yourdon软件开发模型可以看出，OOAD方法的对象模型被划分为五个层次：主题层（也称为范畴层）、类与对象层、结构层、属性层和服务层。

1. Coad-Yourdon的OOA

   Coad-Yourdon的OOA目标是开发一系列模型，用来描述客户需求的计算机软件，定义所有与待求解问题有关的类。为了达到该目标，必须完成下面六个任务：

   1. 在客户和软件工程师之间沟通，了解基本的用户需求。
   2. 标识类。
   3. 划分类层次
   4. 表示对象间关系
   5. 建立对象的行为模型
   6. 在任务1～5之间重复，直到完成建模

   OOA的过程分为五个步骤：

   1. 发现和标识类及对象。描述如何发现类及对象。从应用领域开始识别类及对象，形成整个应用的基础，然后，据此分析系统的责任。
   2. 识别类结构。该阶段分为两个步骤。第一，识别一般-特殊结构，该结构捕获了识别出的类的层次结构；第二，识别整体-部分结构，该结构用来表示一个对象如何成为另一个对象的一部分，以及多个对象如何组装成更大的对象。
   3. 定义主题。主题由一组类及对象组成，用于将类及对象模型划分为更大的单位，便于理解。
   4. 定义属性。其中包括定义类的实例（对象）之间的实例连接。
   5. 定义服务。其中包括定义对象之间的消息连接。

   在面向对象分析阶段，经过五个层次的活动后的结果是一个分成五个层次的问题域模型，包括主题、类及对象、结构、属性和服务五个层次。由类及对象图表示。五个层次活动的顺序并不重要。

2. Coad-Yourdon的OOD方法

   像其他的设计方法一样，面向对象的设计目标是生成对真实世界问题域的表示并将之映射到解域，也就是映射到软件上。

   Coad-Yourdon的OOD阶段继续采用OOA阶段的五个层次，这样有利于从分析到设计的过渡。同时，它又引入了4个组成部分，即问题域部分（PDC）、人-机交互部分（HIC）、任务管理部分（TMC）和数据管理部分（DMC）。

   1. 问题域部分（PDC）。面向对象分析的结果直接放入该部分。
   2. 人-机交互部分（HIC）这部分的活动包括对用户分类，描述人-机交互的脚本，设计命令层次结构，设计详细的交互，生成用户界面的原型，定义HIC类。
   3. 任务管理部分（TMC）。这部分的活动包括识别任务（进程），任务所提供的服务，任务的优先级，进程是事件驱动还是时钟驱动，以及任务与其他进程和外界如何通信。
   4. 数据管理部分（DMC）。这一部分依赖于存储技术是文件系统、生态系统数据库管理系统，还是面向对象数据库管理系统。

#### OMT面向对象方法

面向对象模型化技术（Object Modeling Technique，OMT）方法最早是由Loomis、Shan和Rumbaugh 在1987年提出的，曾扩展应用于关系数据库设计。Jim Rumbaugh 在1991年正式把OMT应用于面向对象的分析和设计。这个方法是在实体关系模型上扩展了类、继承和行为而得到的。

OMT方法的优点与不足

1. 优点
   - 体现了面向对象软件开发中以模型驱动的基本思想，将软件开发的中心转移到分析阶段。
   - 全面支持OO概念，具有很强的应用性。OMT支持软件开发的分析、设计和实现的全过程，并且对开发过程的描述比其他方法要详细清楚，工作步骤具体，建模能力强。
2. 不足之处
   - 建模过程描述不是很清楚，不能具体地体现建模过程。
   - 图形表示在大型复杂系统中应用时是不容易画得有条理和清楚的。
   - 对系统的描述是不够详细的
   - OMT 方法的模型不含有语义成分，描述系统不够精确，容易产生二义性。
   - 三种模型的一致性是难以检测和维护的。
   - 对系统约束的描述能力不够强。
