# 第三章

- MySQL 5.1及更新的版本中，可以通过设置long_query_time为0来捕获所有的查询，而且查询的响应时间可以做到微秒级。
- 慢查询日志是开销最低、精度最高的测量查询时间的工具。如果还在担心开启慢查询日志会带来额外的IO 开销，那大可放心。我们在IO 密集型的场景做过基准测试，慢查询日志带来的开销可以忽略不计。
- 更需要担心的是日志可能消耗大量的磁盘空间。
- **如果长期开启慢查询日志，注意要部署日志轮转(log rotation)工具。或者不要长期启用慢查询日志，只在需要收集的时候开启**
- MySQL 还有另外一种查询日志，称为“通用日志”。
- 不要直接打开整个慢查询日志进行分析，应该先从慢查询日志中生成剖析报告。生成剖析报告需要一个好工具。

### MySQL 日志文件系统组成

- 错误日志：记录启动、运行或停止mysqld时出现的问题。
- 通用日志：记录建立的客户端连接和执行的语句。
- 更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。
- 二进制日志：记录所有更改数据的语句。还用于复制。
- 慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询。
- Innodb日志：innodb redo log

### show profile

做剖析(profiling)用的

### show status

- MySQL 的show status 命令会返回一些计数器。既有服务器级别的全局计数器，也有基于某个连接的会话级计数器。
- 例如其中的Queries，在会话开始时为0，每提交一个查询增加1。
- 如果执行`show global status`，则可以查看服务器级别的从服务器启动时开始计算的查询次数统计
- `show status` 是一个有用的工具，但并不是一个剖析工具。`show status` 的大部分结果都只是一个计数器，可以显示某些活动如读索引的频繁程度，但无法给出消耗了多少时间
- `show status` 结果中只有一条指的是操作的时间，（Innodb_row_lock_time），而且只能是全局级的，所以还是无法测量会话级的工作

### show processlist

- 通过不停地捕获`show processlist` 的输出，来观察是否有大量线程处于不正常的状态或者有其它不正常的特征。
- 例如查询很少会长时间处于“statistics” 状态，这个状态一般是指导服务器在查询优化阶段如何确定表关联的顺序——通常是很快的
- 使用`show processlist` 命令时，在尾部加上\G 可以垂直地方式输出结果，可以很方便的sort|uniq|sort 一类的命令来计算列值出现的次数
- 线程处于查询执行的结束部分的状态，包括“freeing items”，“end”，“cleaning up” 和“logging show query”
- 大量的线程处于“freeing items” 状态是出现了大量有问题查询的很明显的特征和指示
- **一个很经典的例子是，很多查询处于“Locked” 的状态，这是MyISAM的一个典型问题，它的表级别锁定，在写请求较多时，可能迅速导致服务器级别的纯种堆积。**

```sh
cotilla@mng-39:/data1/cv-dockers/repl$ mysql -h10.111.1.50 -P3317 -u dev -psyn  -e 'show processlist \G;' | grep State| sort | uniq -c | sort -rn
mysql: [Warning] Using a password on the command line interface can be insecure.
   1127   State:
      3   State: Master has sent all binlog to slave; waiting for more updates
      1   State: starting
      1   State: Waiting on empty queue
```

缺省情况下，所有日志创建于mysqld数据目录中。
可以通过刷新日志，来强制mysqld来关闭和重新打开日志文件（或者在某些情况下切换到一个新的日志）。
当你执行一个FLUSH LOGS语句或执行mysqladmin flush-logs或mysqladmin refresh时，则日志被老化。
对于存在MySQL复制的情形下，从复制服务器将维护更多日志文件，被称为接替日志。

### 使用查询日志

- 如果要通过查询日志发现问题，需要开启慢查询日志并在全局级别设置`long_query_time` 为0。并且要确认所有的连接都采用了新的设置。这可能需要重置所有接连以使新的全局设置生效；或者使用Percona Server的一个特性，可以在不断开现有连接的情况下动态地使设置强制生效。

# 第四章知识点

## 4.1 选择优化的数据类型

- 正确存储数据的最小类型，更小的通常更快，占用更少的磁盘、内存和CPU缓存，处理时需要的CPU周期也更少
- 整形比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整形比较更复杂
- 要使用MySQL内建的类型（date,time,datatime）而不是字符串来存储日期和时间
- 应该用整形存储IP 地址
- 尽量避免Null--通常情况下最好指定列为NOT NULL，除非真的需要存储NULL 值
- 如果查询中包含可为NULL 的列，对MySQL 来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更为复杂。可为NULL 的列会使用更多的存储空间，在MySQL 里也需要特殊处理。当可为NULL 的列被索引时，每个索引记录需要一个额外的字节
- 通常把可为NULL 的列改为NOT NULL带来的性能提升比较小，所以（调优时）没有必要首先在现有schema 中查找并修改这种情况
- **如果计划在列上建索引，就应该尽量避免设计成可为NULL 的列。**
- InnoDB 使用单独的位（bit）来存储NULL 值，所以对于稀疏数据有很好的空间效率。不适用于MyISAM
- DateTime 和TIMESTAMP都可以存储相同类型的数据：时间和日期，精确到秒。然而TimeStamp只使用DateTime 一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。另一方面，TimeStamp 允许的时间范围要小得多，有时候它的特殊能力会成为障碍


### 4.1.1 整数类型

- 有两种类型的数字：整数和实数。整数可以使用：tinyint, smallint, mediumint, int, bigint，分别使用了8,16,24,32,64 位存储空间
- 整数类型有可选的unsigned 属性，表示不允许负值，可以使正数的上限提高一倍。例如tinyint unsigned 可以存储0-255，而tinyint 存储范围是-128 - 127
- **有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据实际情况选择合适的类型。**
- 你的选择决定MySQL是怎么在内存和磁盘中保存数据。然而整数计算一般使用64 位的bigint整数（一些聚合函数例外，它们使用decimal 或double 进行计算）
- MySQL 可以为整数类型指定宽度，例如int(11)，对大多数应该这是没有意义的：它不会限制值的合法范围，只是规定了MySQL 的一些交互工具（例如MySQL 命令行客户端）用来显示字符的个数。**对于存储和计算来说，int(1) 和int(20)是相同的

### 4.1.2 实数类型

- 实数是带有小数部分的数字。可以使用decimal 存储比bigint 还大的整数。MySQL 支持精确类型，也支持不精确类型
- FLOAT 和DOUBLE类型支持使用标准的浮点运算进行近似计算
- decimal 类型用于存储精确的小数，MySQL 5.0 以及更高的版本中，MySQL 服务器自身实现了decimal 的高精度计算。相对而言，CPU 直接支持原生浮点计算，所以浮点运算明显更快
- 浮点和decimal 类型都支持指定精度。MySQL 5.0 和更高版本将数字打包到保存到一个二进制字符串中（每4 个字节存9 个数字）例如，`decimal(18,9)` 小数点两边将各存储9 个数字，一共使用9 个字节：小数点前4 个字节，小数点1 个字节，后面4 个字节。
- MySQL 5.0 及更高版本中的decimal 类型允许最多65 个数字。早期的限制是254 个数字。早期版本实际上并不能在计算中使用这么大的数字，因为decimal 只是一种存储格式，在计算中decimal 会转换到double类型。
- 浮点类型在存储同样范围的值时，通常比decimal 使用更少的空间。float 占用4 个字节，double 占用8 个字节。和整数一样，能选择的只是存储类型，MySQL 使用double 作为内部浮点计算的类型
- 因为需要额外空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用decimal——例如存储财务数据。在数据量比较大的时候，可以考虑使用bigint代替decimal，将需要存储的单位根据小数的位数乘以相应的倍数即可。比如乘以1百万，然后将结果存储在bigint 里，这样可以同时避免浮点存储计算不精确和decimal 精确计算代价高的问题

### 4.1.3 字符串类型

- MySQL 从4.1 开始，每个字符串列可以定义自己的字符集和排序规则，或者说校对规则(collation)。这些东西很大程序上影响性能

#### varchar 和char 类型

##### varchar

- 存储可变长度字符串。它比定长类型更节省空间，因为它仅使用必要的空间（越短的字符串使用越少的空间）。有一种例外情况，如果MySQL 表使用`row_format=fixed` 创建的话，每一行都会使用定长存储，这会很浪费空间
- varchar 需要使用1 个或者2 个额外的字节记录字符串的长度：如果列长最大长度小于或等于255 字节，则只使用1 个字节表示，否则使用2 个字节。假设采用latin1 字符集，一个varchar(10) 的列需要11 个字节的存储空间，varchar(1000) 的列需要1002 个字节，因为需要2 个字节存储长度信息
- varchar 节省了存储空间，所以对性能也有帮助。由于行是变长的，在update 时可能使行变得比原来更长，这就导致需要做额外的工作。不同的存储引擎处理方式是不一样的，MyISAM 会将行拆成不同的片段存储，InnoDB 则需要分裂页来使行可以放进页内
- 以下情况使用varchar 合适：
  - 字符串列的最大长度比平均长度大很多
  - 列的更新很少，所以碎片不是问题
  - 使用了像UTF-8 这样复杂的字符集，每个字符都使用不同的字节数进行存储
  - InnoDB 会更灵活，它可以把过长的varchar 存储为blob

char

- 定长的，MySQL 问题根据定义的字符串长度分配足够的空间，会删除末尾的空格。
- 适合存储很短的字符串，或者所有值都接近同一个长度。例如char 非常适合存储密码的MD5值。
- 对于经常变更的数据，char 也比varchar 更好，因为定长的char 类型不容易产生碎片
- 对于非常短的列，char比varchar 在存储空间上也更有效率。例如用char(1) 来存储只有Y 和N 的值，只需要一个字节。**但是varchar(1) 却需要两个字节，因为还有一个记录长度的额外字节**

正文

- 与char 和varchar 类似的类型还有binary 和varbinary，它们存储的是二进制的字符串。二进制字符串跟常规字符串非常相似，但是二进制字符串存储的是字节码而不是字符，用`\0` 填充，而不是空格。在检索时也不会去掉填充值
- 二进制比较的优势并不仅仅体现在大小写敏感上。MySQL 比较binary 字符串时，每次按一个字节，并且根据该字节的数值进行比较。二进制比较比字符比较简单很多，所以更快。

- 使用varchar(5) 和varchar(200) 存储`hello` 的空间开销是一样的，但是使用更短的列有很大优势，更长的列会消耗更多的内存，因为MySQL 通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时，会特别糟糕。在利用磁盘临时表进行排序的时候也同样糟糕。
- **所以，最好的策略是只分配真正需要的空间。**

#### blob 和text 类型

- blob 和text 都是为存储很大的数据而设计的字符串数据类型，分别**采用二进制和字符方式存储**。
- 分别属于两个不同的数据类型家族，字符类型是tinytext, smalltext, text, mediumtext, longtext；对应的二进制类型是tinyblob, smallblob, blob, mediumblob, longblob
- blob 和text 家族之间仅有的不同是： blob 类型存储的是二进制数据，没有排序规则或字符集，而text 类型有字符集和排序规则。
- MySQL 对blob 和text 列进行排序与其他类型是不同的：它只对每个列的最前`max_sort_length` 字节而不是整个字符串做排序。如果只需要排序前面一小部分字符，则可以减小`max_sort_length` 的配置，或者使用`order by substring(column, length)`。
- MySQL 不能将blob 和TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。
- 因为Memory 引擎不支持blob和text 类型，所以如果查询使用了blob 或text 列并且需要使用隐式临时表，将不得不使用MyISAM 磁盘临时表，即使只有几行数据也是如此。**这会导致严重的性能开销。**最好的解决方案是尽量避免使用blob和text 类型。
- 如果实在无法避免，有一个技巧是在所有用到blob 字段的地方都使用`substring(column,length)` 将列值转换为字符串(在order by 子句中也适用)，这样就可以使用临时表了。**但是要确保截取的子字符串足够短，不会使临时表的大小超过`max_heap_table_size` 或`tmp_table_size`，超过以后，MySQL会将内存临时表转换为MyISAM 磁盘临时表。**
- **如果`explain` 执行计划的`extra` 列包含`using temporary`，则说明这个查询使用了隐式临时表。**

#### 使用枚举(enum) 代替字符串类型

- 有时候可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表的`.frm` 文件中保存“数字-字符串” 映射关系的查找表。
- 当把列都转换成ENUM 以后，关联变得很快。这是一个通用的设计实践，**在查找表时采用整数主键而避免采用基于字符串的值进行关联。**
- **转换列为枚举类型还有另一个好处。根据`SHOW TABLE STATUS` 命令输出结果中`Data_length` 列的值，把这两列转换为`ENUM` 可以让表的大小缩小1/3。同样转换后主键孔只有原来的一半大小了。因为这是InnoDB 表，如果表上有其它索引，减小主键大小会使非主键索引也变得更小。**

### 4.1.4 日期和时间类型

- MySQL可以使用许多类型来保存日期和时间值，例如YEAR和DATE。**MySQL 能存储的最小时间粒度为秒**（MariaDB支持微秒级别的时间类型）。
- MySQL 提供两种相似的日期类型：`DATETIME` 和`TIMESTAMP`。
- datetime
  - **这个类型能保存大范围的值，从1001年到9999 年，精度为秒。它把日期和时间封装到格式为`YYYYMMDDHHMMSS` 的整数中，与时区无关。使用8 个字节的存储空间。**
  - 默认情况下，MySQL以一种可排序的、无歧义的格式显示DATETIME值，例如：“2008-01-16 22:37:08”。这是ANSI标准定义的日期和时间表示方法

- timestamp
  - 就像名字一样，timestamp类型保存了从1970的1月1日午夜(格林尼治标准时间)以来的**秒数**，它和UNIX 时间戳相同。只使用了4 个字节的存储空间，因此范围比datetime 小得多：**只能表示从1970年到2038年。**MySQL 提供了FROM_UNIXTIME() 函数把UNIX 时间戳转换为日期，并提供了UNIX_TIMESTAMP() 函数把日期转换为Unix 时间戳。
  - timestamp显示的值也依赖于时区。MySQL 服务器、操作系统，以及客户端连接都有时区设置。因此，存储值为0 的timestamp 在美国东部时区显示为“1969-12-31 19:00:00”，与格林尼治时间差5 个小时。**强调一下这个区别：如果在多个时区存储或访问数据，timestamp 和datetime 的行为将很不一样。前者提供的值与时区有关系，后者则保留了文本表示的日期和时间。**
  - timestamp也有datetime 没有的特殊属性。默认情况下，如果插入时没有指定第一个timestamp 列的值，MySQL 则设置这个列的值为当前时间。**timestamp 的行为规则比较复杂，并且在不同的MySQL 版本里会变动。所以你应该验证数据库的行为。**
- **除了特殊行为之外，通常也应该尽量使用timestamp，因为它比datetime 的空间效率更高。**有时人们会将Unix 时间戳存储为整数值，这不会带来任何收益。**用整数来保存时间戳的格式通常不方便处理，所以不推荐这样做。**
- 如果需要更小粒度的日期和时间值，MySQL 5 没有提供合适的数据类型，但是可以使用自己的存储格式：**可以使用bigint类型存储微秒级别的时间戳，或者使用double 存储秒之后的小数部分。或者也可以使用MariaDB 替代MySQL。**

### 4.1.5 位数据类型

- MySQL有少数几种存储类型使用紧凑的位存储数据。所有这些类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。
- BIT
  - 在5.0 之前，BIT 是TINYINT 是同义词，但是在5.0 以及更新版本中，完全不同了。
  - 可以使用BIT 列在一列中存储一个或者多个true / false 值。BIT(1) 定义一个包含单个位的字段，BIT(2) 存储2 个位。BIT 列的最大长度是64 个位
  - BIT 的行为因存储引擎而异。**MyISAM 会打包存储所有的BIT 列，所以17个单独的BIT 列只需要17 个位存储(假设没有可为NULL的列)**，这样MyISAM 只使用3 个字节就能存储这17个BIT列。**其它存储引擎例如Memory和InnoDB，为每个BIT 列使用一个足够存储的最小整数类型来存放，所以不能节省存储空间。**
  - MySQL把BIT 当作字符串类型，而不是数字类型。当检索BIT(1) 的值时，结果是一个包含二进制0 或1值的字符串，而不是ASCII 码的0 或1。然而，在数字上下文的场景中检索时，结果将是字符串转换成的数字。如果需要和另外的值比较结果，一定要记得这一点

### 4.1.6 选择标识符(identifier)

- 为标识列(identifier column) 选择合适的数据类型非常重要。一般来说更有可能用标识列与其它列进行比较，或者通过标识列来寻找其他列。标识列也可能在另外的表中作为外键使用，**所以在为标识列选择数据类型时，应该选择跟关联表中的对应列一样的类型。**
- **当选择标识列的类型时，不仅需要考虑存储类型，还需要考虑MySQL 对这种类型是怎么执行计算和比较的。例如，MySQL 在内部使用整数存储ENUM 和SET 类型，然后在做比较操作时转换为字符串。**
- 类型之间需要精确匹配，包括像unsigned 这样的属性。**混用不同数据类型可能导致性能问题，即使没有性能影响，在比较操作时，隐式类型转换也可能导致很难发现的错误。这种错误可能会很久以后才出现。**
- 例如有一个state_id 存储美国各个州的名字，不需要使用int，tinyint 足够存储，比int 少了3 个字节，如果用这个值作为其他表的外键，3 个字节可能导致很大的性能差异

- 整数通常是标识列最好的选择，因为它们很快，并且可以使用auto_increment
- Enum 和set 类型，对于标识列来说，enum 和set 通常是一个糟糕的选择。尽管对某些只包含固定状态或者类型的静态“定义表”来说可能没问题。
- Enum 和set 列适合存储固定信息，例如有序的状态、产品类型、人的性别
- 字符串类型，如果可能，应该避免使用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。尤其是在MyISAM 表里使用字符串作为标识列时要特别小心。**MyISAM 默认对字符串使用压缩索引，这会导致查询慢得多。我们测试到最多有6 倍的性能下降。**
- 对于完全“随机” 的字符串也需要注意，例如md5，sha1 或者uuid 产生的字符串。这些值会分布在很大的空间内，会导致insert 和select 变得很慢。
  - 因为插入值会导致随机地写到索引的不同位置，所以使得insert 慢，会导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。
